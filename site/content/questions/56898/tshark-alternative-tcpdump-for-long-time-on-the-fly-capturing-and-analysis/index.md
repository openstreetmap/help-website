+++
type = "question"
title = "tshark alternative (tcpdump?) for long-time on-the-fly capturing and analysis"
description = '''Hi, I have developed a Java program, and one of its threads runs a tshark command and listens on its command-line output and performs analysis in real time.  The network topology is that dozens of clients request HTTP content from a server, and I&#x27;m running the program on the server:8080.  The tshark...'''
date = "2016-11-01T06:11:00Z"
lastmod = "2016-11-03T14:00:00Z"
weight = 56898
keywords = [ "capture", "tcpdump", "tshark" ]
aliases = [ "/questions/56898" ]
osqa_answers = 2
osqa_accepted = false
+++

<div class="headNormal">

# [tshark alternative (tcpdump?) for long-time on-the-fly capturing and analysis](/questions/56898/tshark-alternative-tcpdump-for-long-time-on-the-fly-capturing-and-analysis)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-56898-score" class="post-score" title="current number of votes">0</div><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>Hi, I have developed a Java program, and one of its threads runs a tshark command and listens on its command-line output and performs analysis in real time.</p><p>The network topology is that dozens of clients request HTTP content from a server, and I'm running the program on the server:8080.</p><p>The tshark command I'm using is:</p><pre><code>tshark -B 40 -i any -l -f tcp -t e -n -Y tcp.port==8080</code></pre><p>The requirements that made me chose tshark are:</p><ol><li>I need to identify packets that contain an HTTP GET request</li><li>I need to see each data packet that is sent from the server:8080 to any client (most likely with a length of 1516 bytes)</li></ol><p>I just discovered that tshark's memory footprint keeps increasing (which has been extensively discussed on this site), which makes it unsuitable for long-term running (months). For example, if I run tshark for 10 minutes on my server, its RAM usage will reach 4GB (according to "top"). Note that I need to analyse each packet on-the-fly, so ring buffer is not an option either.</p><p>I understand that many folks on this site recommends tcpdump as an alternative to tshark. However, for performance requirement, I cannot afford to let tcpdump output every single packet's payload and then look for HTTP GET.</p><p>Ideally, I'm looking for a program that can produce output like this to command-line (I'm using tcpdump output as a template):</p><pre><code>[timestamp] IP user1.38572 &gt; server.8080 ...
HTTP GET url/url...
[timestamp] IP server.8080 &gt; user1.38572 flags [.] ack xxx, length 1516
[timestamp] IP server.8080 &gt; user1.38572 flags [.] ack xxx, length 1516
[timestamp] IP server.8080 &gt; user1.38572 flags [.] ack xxx, length 1516</code></pre><p>Is there a one-liner for tcpdump that can do this, or any other advice is highly appreciated.</p></div><div id="question-tags" class="tags-container tags">capture tcpdump tshark</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>01 Nov '16, 06:11</strong></p><img src="https://secure.gravatar.com/avatar/5b505a91634dbad2eb6c081340c7197f?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Chang&#39;s gravatar image" /><p>Chang<br />
<span class="score" title="16 reputation points">16</span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="3 badges"><span class="silver">●</span><span class="badgecount">3</span></span><span title="7 badges"><span class="bronze">●</span><span class="badgecount">7</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Chang has no accepted answers">0%</span></p></div></div><div id="comments-container-56898" class="comments-container"></div><div id="comment-tools-56898" class="comment-tools"></div><div class="clear"></div><div id="comment-56898-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

2 Answers:

</div>

</div>

<span id="56954"></span>

<div id="answer-container-56954" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-56954-score" class="post-score" title="current number of votes">1</div></div></td><td><div class="item-right"><div class="answer-body"><p>You can use tcpdump to do what you want. The filters are pretty powerful and flexible. In your case, you probably want anything headed for a given port (say 80), and with the string 'GET ' as the first 4 packets in the payload. You can use the expression below to create such a filter:</p><pre><code>( dst port 80 ) and ( tcp[20:4] == 0x47455420 )</code></pre><p>the tcp[20:4] == 0x47455420 tells tcpdump to save anything where the 4 packets starting at byte #20 in the TCP packet equal the bytes 0x47 0x45 0x54 0x20 (which is just hex for 'GET '. The number of packets to match must be an even power of 2, so you need that 4th byte corresponding to the space). This assumes, of course, that you have a 20 byte tcp header with no options.</p><p>As far as performance goes (if you are running a modern linux system) tcpdump should be compiling the filter into bytecode and handing it off to the kernel to execute against packets as the come in. If you are interested, you can actually see the little program it creates using the -d option. If you are load/latency tolerant enough that you were considering running tshark on the server anyway, you will probably be OK</p><pre><code>tcpdump -d &#39;( dst port 80 ) and ( tcp[20:4] == 0x47455420 )&#39;
(000) ldh      [12]
(001) jeq      #0x86dd          jt 14   jf 2
(002) jeq      #0x800           jt 3    jf 14
(003) ldb      [23]
(004) jeq      #0x84            jt 14   jf 5
(005) jeq      #0x6             jt 6    jf 14
(006) ldh      [20]
(007) jset     #0x1fff          jt 14   jf 8
(008) ldxb     4*([14]&amp;0xf)
(009) ldh      [x + 16]
(010) jeq      #0x50            jt 11   jf 14
(011) ld       [x + 34]
(012) jeq      #0x47455420      jt 13   jf 14
(013) ret      #65535
(014) ret      #0</code></pre></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>03 Nov '16, 14:00</strong></p><img src="https://secure.gravatar.com/avatar/ba1199f4d360c53a6cc8aa6aa5da37c8?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="ryber&#39;s gravatar image" /><p>ryber<br />
<span class="score" title="146 reputation points">146</span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="5 badges"><span class="silver">●</span><span class="badgecount">5</span></span><span title="9 badges"><span class="bronze">●</span><span class="badgecount">9</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="ryber has one accepted answer">16%</span></p></div></div><div id="comments-container-56954" class="comments-container"><span id="56955"></span><div id="comment-56955" class="comment"><div id="post-56955-score" class="comment-score">1</div><div class="comment-text"><p>I'm afraid the filter suggested above fails to match GET packets whose TCP header is augmented with some options. On <a href="https://wiki.wireshark.org/CaptureFilters">Wireshark wiki page on capture filters</a>, there is a capture filter which addresses this:</p><p><code>port 80 and tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420</code></p><p>Even with this filter, there is still a theoretical chance to get some false positives if a <code>GET</code> string occurs somewhere in the headers of a http request which spans more than a single segment and falls at the beginning of a TCP segment. Also, I would add <code>dst</code> before <code>port 80</code> as we are not interested in packets carrying http responses and their bodies - there are much more likely to contain a <code>GET</code> string than the headers of requests.</p></div><div id="comment-56955-info" class="comment-info"><span class="comment-age">(03 Nov '16, 14:42)</span> sindy</div></div><span id="56956"></span><div id="comment-56956" class="comment"><div id="post-56956-score" class="comment-score"></div><div class="comment-text"><p>Good suggestion about handling the possibility of TCP options.<br />
</p><p>The filter as written above does already have 'dst' before 'port'.</p><p>Good point about the chance of false positives in the event of a fragmented HTTP request that starts with 'GET ' as the first four bytes. How to handle that (as well as requests fragmented across multiple TCP packets) would come down to the use case. It might be easier to handle when the data is being analyzed.</p><p>@Chang could also build a more complex filter that looks for a few more characters following GET (such as '/...') to reduce false positives.</p></div><div id="comment-56956-info" class="comment-info"><span class="comment-age">(03 Nov '16, 14:55)</span> ryber</div></div><span id="56958"></span><div id="comment-56958" class="comment"><div id="post-56958-score" class="comment-score"></div><div class="comment-text"><blockquote><p>The filter as written above does already have <code>dst</code> before <code>port</code>.</p></blockquote><p>Yours did, but the one at the wiki page didn't, that's why I've mentioned that.</p></div><div id="comment-56958-info" class="comment-info"><span class="comment-age">(03 Nov '16, 15:00)</span> sindy</div></div><span id="56968"></span><div id="comment-56968" class="comment not_top_scorer"><div id="post-56968-score" class="comment-score"></div><div class="comment-text"><p>Thanks @ryber and @sindy, I have tried the capture filters you mentioned above, and I can see that TCP packets containing HTTP GET requests are correctly captured.</p><p>However, this still does not meet my requirements:</p><ul><li>I need to see the URL of the GET request.</li><li>I need to see all other data packets sent from server:8080 to client printed out too (in the format of ACKs sent as segmented HTTP response).</li></ul><p>Any advice?</p></div><div id="comment-56968-info" class="comment-info"><span class="comment-age">(04 Nov '16, 02:29)</span> Chang</div></div><span id="56969"></span><div id="comment-56969" class="comment not_top_scorer"><div id="post-56969-score" class="comment-score"></div><div class="comment-text"><p>I just tried using the filter below (changed "and" to "or):</p><pre><code>port 8080 or tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420</code></pre><p>and used -A option of tcpdump to print out the payload content.</p><p>Now I can see the GET request content (great!), but I can also see tons of data of HTTP response printed out (yuck!). For the HTTP response packets, I just need to see one line showing the packet without the payload (like when there is no -A option).</p></div><div id="comment-56969-info" class="comment-info"><span class="comment-age">(04 Nov '16, 02:41)</span> Chang</div></div><span id="56970"></span><div id="comment-56970" class="comment not_top_scorer"><div id="post-56970-score" class="comment-score"></div><div class="comment-text"><p>To see the url of the GET request, it should be enough to use tcpdump's command line options making it print the contents of the packets, and apply a sed or awk filter on it to extract only the url.</p><p>But to see the contents of the server responses, you need to track the context (state), and tracking state is exactly what causes the continuous growth of memory consumption in tshark. So I'm afraid that your only way out is to let tcpdump or dumpcap capture into a circular buffer of files, using a only a basic capture filter like <code>tcp port 8080</code>, and some automated post-processing of these files.</p></div><div id="comment-56970-info" class="comment-info"><span class="comment-age">(04 Nov '16, 02:45)</span> sindy</div></div><span id="56971"></span><div id="comment-56971" class="comment"><div id="post-56971-score" class="comment-score">1</div><div class="comment-text"><blockquote><p>I can also see tons of data of HTTP response printed out</p></blockquote><p>In fact, the <code>or</code> between the <code>port 8080</code> and the rest of the filter expression effectively masks out the rest of the expression for packets which have source or destination port 8080. Also, you cannot use <code>-A</code> for some packets and not use it for others for the same instance of tcpdump.</p></div><div id="comment-56971-info" class="comment-info"><span class="comment-age">(04 Nov '16, 02:51)</span> sindy</div></div><span id="56974"></span><div id="comment-56974" class="comment not_top_scorer"><div id="post-56974-score" class="comment-score"></div><div class="comment-text"><p>@sindy I don't need to track the states of HTTP response - all I need to see is the packets themselves that are being sent from server to client (so that I can manually add up packet-by-packet how many bytes have been sent in response to a previous GET request).</p><p>Based on your comments so far, I think sed might be the way to do this - I just need to filter &amp; print 2 types of lines:</p><ul><li>All tcpdump regular output (i.e., the output without -A)</li><li>The line containing GET and URL</li></ul><p>Unfortunately I'm not very good at regex...can you please provide some initial guidelines on where I should start, thanks!</p></div><div id="comment-56974-info" class="comment-info"><span class="comment-age">(04 Nov '16, 03:14)</span> Chang</div></div><span id="56977"></span><div id="comment-56977" class="comment"><div id="post-56977-score" class="comment-score">2</div><div class="comment-text"><p>We are getting close to the edge of the site scope...</p><p>I'm afraid you neglect the possibility of packet loss and subsequent retransmissions, i.e. you assume that each GET request in client-&gt;server direction is followed by properly ordered packets of a matching response in the server-&gt;client direction. This is not always the case, that's why I've mentioned the context - HTTP uses TCP as transport, and in tshark or wireshark, the TCP dissector takes care of hiding network problems from the HTTP dissector, not giving it any piece of data until all previous ones have been completely received, and not giving it any retransmitted data once again.</p><p>Leaving that aside, you may use <code>-x</code> rather than <code>-A</code>, making tcpdump print out hex dumps of the packets rather than their text representations, as the contents of the responses may be encoded in many ways, not all of them printable. Your post-process would then evaluate the headers and handle the requests one way and the responses another way.</p><p>Or, if you software can handle two input pipes, you can feed one with the GETs as ASCII and the other one with the responses as hex dumps.</p><p>To answer your question, if the request packet looks as follows:</p><p><code>GET some/url/ HTTP/1.1\r\n HeaderX: ...\r\n HeaderY: ...\r\n</code></p><p>you may use <code>sed 's/^GET \([^ ]*\) HTTP.*/\1/'</code> to extract only <code>some/url/</code> from the first line, but I cannot tell you how to get rid of the rest of the lines as it largely depends on your system, handling of control characters differs a lot.</p></div><div id="comment-56977-info" class="comment-info"><span class="comment-age">(04 Nov '16, 04:07)</span> sindy</div></div><span id="56978"></span><div id="comment-56978" class="comment not_top_scorer"><div id="post-56978-score" class="comment-score"></div><div class="comment-text"><p>@sindy when I was using tshark, I have already disabled all dissecting options and I have already built my software to handle retransmissions on per-segment level.</p><p>I think I will follow your suggestion on using 2 tcpdump input pipes in parallel and work something out...thanks again.</p></div><div id="comment-56978-info" class="comment-info"><span class="comment-age">(04 Nov '16, 04:32)</span> Chang</div></div></div><div id="comment-tools-56954" class="comment-tools"><span class="comments-showing"> showing 5 of 10 </span> <a href="#" class="show-all-comments-link">show 5 more comments</a></div><div class="clear"></div><div id="comment-56954-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<span id="56900"></span>

<div id="answer-container-56900" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-56900-score" class="post-score" title="current number of votes">0</div></div></td><td><div class="item-right"><div class="answer-body"><p>Seems to me like you should be looking at a tool like <a href="https://www.snort.org/">Snort</a>, <a href="https://suricata-ids.org/">Suricata</a> or <a href="https://www.bro.org/">Bro</a> instead, which are made for on-the-fly packet content matching and alerting.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>01 Nov '16, 07:47</strong></p><img src="https://secure.gravatar.com/avatar/c578ba2967741f25aebd6afef702f432?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Jasper&#39;s gravatar image" /><p>Jasper ♦♦<br />
<span class="score" title="23806 reputation points"><span>23.8k</span></span><span title="5 badges"><span class="badge1">●</span><span class="badgecount">5</span></span><span title="51 badges"><span class="silver">●</span><span class="badgecount">51</span></span><span title="284 badges"><span class="bronze">●</span><span class="badgecount">284</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Jasper has 263 accepted answers">18%</span> </br></p></div></div><div id="comments-container-56900" class="comments-container"><span id="56901"></span><div id="comment-56901" class="comment"><div id="post-56901-score" class="comment-score"></div><div class="comment-text"><p>Thanks, I've looked at Snort's "sniffer mode" - how is this different from plain tcpdump?</p></div><div id="comment-56901-info" class="comment-info"><span class="comment-age">(01 Nov '16, 08:06)</span> Chang</div></div><span id="56902"></span><div id="comment-56902" class="comment"><div id="post-56902-score" class="comment-score"></div><div class="comment-text"><p>I think the sniffer mode isn't that much different. What you need is the pattern matching capabilities of Snort which can run for years without running into the same memory trouble while being able to match patterns on-the-fly. I think you'll need to do a full packet capture at the same time, and then script something to use the hits found by Snort to extract all packets belonging to that hit.</p></div><div id="comment-56902-info" class="comment-info"><span class="comment-age">(01 Nov '16, 08:11)</span> Jasper ♦♦</div></div><span id="56924"></span><div id="comment-56924" class="comment"><div id="post-56924-score" class="comment-score"></div><div class="comment-text"><p>@Jasper are you suggesting that there's no way to do "sniffer" and "alert" mode at the same time? I.e., I might need to start 2 separate threads with one running on sniffer mode and the other one that alerts me when an HTTP GET is detected?</p></div><div id="comment-56924-info" class="comment-info"><span class="comment-age">(02 Nov '16, 02:50)</span> Chang</div></div></div><div id="comment-tools-56900" class="comment-tools"></div><div class="clear"></div><div id="comment-56900-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

