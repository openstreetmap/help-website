+++
type = "question"
title = "Why are 0 length TCP packets returned on some HTTP / TCP sessions?"
description = '''Why are 0 length TCP packets returned on some HTTP / TCP sessions? We have a mini-httpd server embedded in an application. Sometimes after a HTTP request for a resource the underlying TCP connection doesn&#x27;t work. It only returns TCP packets of message length 0. It&#x27;s on localhost. The only thing that...'''
date = "2016-05-17T18:54:00Z"
lastmod = "2016-05-17T21:56:00Z"
weight = 52702
keywords = [ "httpd", "tcp", "localhost" ]
aliases = [ "/questions/52702" ]
osqa_answers = 0
osqa_accepted = false
+++

<div class="headNormal">

# [Why are 0 length TCP packets returned on some HTTP / TCP sessions?](/questions/52702/why-are-0-length-tcp-packets-returned-on-some-http-tcp-sessions)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-52702-score" class="post-score" title="current number of votes">0</div><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>Why are 0 length TCP packets returned on some HTTP / TCP sessions?</p><p>We have a mini-httpd server embedded in an application. Sometimes after a HTTP request for a resource the underlying TCP connection doesn't work. It only returns TCP packets of message length 0. It's on localhost.</p><p>The only thing that gets it working again (most times) is to stop &amp; start the http client.</p><p><a href="https://osqa-ask.wireshark.org/upfiles/TCP_Packet_Len_0.png">link text</a>Why?<br />
</p></div><div id="question-tags" class="tags-container tags">httpd tcp localhost</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>17 May '16, 18:54</strong></p><img src="https://secure.gravatar.com/avatar/3da823da7b4070dc124ec51c2df30a00?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="WireBananaSlug&#39;s gravatar image" /><p>WireBananaSlug<br />
<span class="score" title="6 reputation points">6</span><span title="2 badges"><span class="badge1">●</span><span class="badgecount">2</span></span><span title="3 badges"><span class="silver">●</span><span class="badgecount">3</span></span><span title="4 badges"><span class="bronze">●</span><span class="badgecount">4</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="WireBananaSlug has no accepted answers">0%</span> </br></p></div><div class="post-update-info post-update-info-edited"><p>edited 17 May '16, 19:36</p></div></div><div id="comments-container-52702" class="comments-container"></div><div id="comment-tools-52702" class="comment-tools"></div><div class="clear"></div><div id="comment-52702-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="52703"></span>

<div id="answer-container-52703" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-52703-score" class="post-score" title="current number of votes">0</div></div></td><td><div class="item-right"><div class="answer-body"><p>Wireshark can help you answer the question "why" only in terms that it shows you which party in communication has stopped responding at a given layer. But the question "why has it stopped responding" may have two answers:</p><ul><li><p>because something was wrong at protocol level, i.e. the other party has sent something which prevents the first one from responding,</p></li><li><p>because something is wrong with that party's application itself.</p></li></ul><p>A "zero-length" TCP packet merely means that the party sending it had no payload to send but needed to inform the other one about something, e.g. about successful reception of data or, vice versa, about missing data which need to be retransmitted.</p><p>In your case, it is hard to say whether the receiving side (the http server) acknowledges the whole http GET packet or only a part of it, because we cannot click to another packet and see what is inside on a screenshot. While "zero-length" TCP packets have 94 bytes of eth + ip + tcp overhead, the GET has total length of 456 bytes and the ACK to it says 181 bytes of payload have been received in it. 94 + 181 = 275; that means there are another 181 bytes in that packet which may be TCP options but these are normally limited to 40 bytes.</p><p>So it seems that the server asks the client to retransmit some data but that is really odd given that the "received" and "still missing" data came in a single packet. Or the 181 unknown bytes in the GET packet are not payload but some extra TCP options, and in that case the server application would have some problem preventing it from sending a (positive or negative) response.</p><p>But both the above are just <em>guesses</em>. We cannot move further in <em>analysis</em> until you back it properly, by posting the capture from which you've taken your screenshot (you can use <code>File -&gt; Export Specified Packets</code> and choose <code>Displayed</code> while the display filter shown on the screenshot is applied to save only the interesting packets), login-free, somewhere like at Cloudshark (preferred by this site's community), Dropbox, Google drive... and post a link to it here.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>17 May '16, 21:56</strong></p><img src="https://secure.gravatar.com/avatar/00fc6e2633725bd871ff636f0175eabc?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="sindy&#39;s gravatar image" /><p>sindy<br />
<span class="score" title="6049 reputation points"><span>6.0k</span></span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="8 badges"><span class="silver">●</span><span class="badgecount">8</span></span><span title="51 badges"><span class="bronze">●</span><span class="badgecount">51</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="sindy has 110 accepted answers">24%</span></p></div></div><div id="comments-container-52703" class="comments-container"><span id="52706"></span><div id="comment-52706" class="comment"><div id="post-52706-score" class="comment-score"></div><div class="comment-text"><p>OK, I've uploaded the captured packets filtered for the port 7888 and it includes 2 sessions. The 1st one that failed and the 2nd one the worked.</p><p>In this case the Unity 3D client requests initially the file that the mini-httpd server that is started by the Unity editor and when it fails that same file gets requested over and over and when it works the Unity 3D client continues to ask for the rest of the files based on the contents of the original file it requested from the Unity 3D mini-httpd server.</p><p>Here is a link to the filtered packets: <a href="https://drive.google.com/file/d/0BxNFAnm5RQuQMjZqUkFJXzVYa2c/view?usp=sharing">link text</a></p><p>Thanks very much.</p></div><div id="comment-52706-info" class="comment-info"><span class="comment-age">(17 May '16, 23:33)</span> WireBananaSlug</div></div><span id="52708"></span><div id="comment-52708" class="comment"><div id="post-52708-score" class="comment-score"></div><div class="comment-text"><p>Hm, that's <em>really</em> weird. WinPcap, like libpcap, stores two frame sizes: the real one as it was "on the wire", and the second is how many bytes of the frame it has stored to the capture file. Different applications (tcpdump and Wireshark) use different default settings: unless you say otherwise manually, Wireshark wants WinPcap to store everything that was on the wire, and tcpdump wants libpcap to store only first 60 bytes.</p><p>In your case, the "stored" length matches the tcp paload size plus headers, while the "on the wire" size is bigger, which doesn't seem reasonable. Therefore, I really would like to know whether you've captured that using npcap (i.e. directly from Wireshark) on the loopback virtual interface or using rawcap.</p><p>If the frame really has 456 bytes on the "wire", it might confuse the receiving chain of the stack and application; otherwise it is most likely a bug of the capturing driver. You should be able to find out by comparing this GET packet with the one in the "good" capture; if for the "good" capture, the first line of the packet dissection pane also says "bytes on wire: N, bytes captured: M" and N&gt;M, then this is most likely just an additional issue but not the root cause of the mini-server's silence in response.</p></div><div id="comment-52708-info" class="comment-info"><span class="comment-age">(18 May '16, 01:11)</span> sindy</div></div><span id="52733"></span><div id="comment-52733" class="comment"><div id="post-52733-score" class="comment-score"></div><div class="comment-text"><p>I have been working with WireBananaSlug on this too and have pretty much identical results from another (Win7) machine with the same WireShark NpCap combo installation. For me the GET on both the failed test and the successful is 452 bytes on wire and 233 bytes captured...</p><p>So have you got any ideas what sort of thing I should look for that might be causing these extra bytes on the wire, that you say might be 'confusing the receiving chain of the stack and application' - I appreciate you cannot say exactly, but any generic ideas about the sort of things that cause this would be really helpful :)</p></div><div id="comment-52733-info" class="comment-info"><span class="comment-age">(18 May '16, 07:51)</span> DOS</div></div><span id="52736"></span><div id="comment-52736" class="comment"><div id="post-52736-score" class="comment-score"></div><div class="comment-text"><blockquote><p>have you got any ideas what sort of thing I should look for</p></blockquote><p>None at all, but I suspect that discrepancy between "on the wire" and "captured" packets to be an issue of npcap or the loopback virtual interface, which implies that there is no way you could affect it directly.</p><p>But as there are two of you dealing with the issue, may I suppose that as you have got two computers, you could run the server on one of them and the client on the other one, capture on their physical network interfaces, and see whether the discrepancy exists in that case too?</p><p>(and yes, I've missed that the capture published already contained both the bad and the good case and that in both of them the difference in frame sizes exists, which most likely means it is a red herring and the actual issue lays somewhere else).</p></div><div id="comment-52736-info" class="comment-info"><span class="comment-age">(18 May '16, 08:08)</span> sindy</div></div><span id="52741"></span><div id="comment-52741" class="comment"><div id="post-52741-score" class="comment-score"></div><div class="comment-text"><p>@sindy - thanks. I guess I will look at some lower level debug error return codes in the OS system, particularly for the file the httpd server is requesting.</p></div><div id="comment-52741-info" class="comment-info"><span class="comment-age">(18 May '16, 10:54)</span> WireBananaSlug</div></div></div><div id="comment-tools-52703" class="comment-tools"></div><div class="clear"></div><div id="comment-52703-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

