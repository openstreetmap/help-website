+++
type = "question"
title = "Custom dissector - Handling of zero length in proto_tree_add_item"
description = '''Hi, I have a question regarding the usage of proto_tree_add_item() in a custom dissector. I encountered a scenario wherein the length parameter to the proto_tree_add_item() function was zero resulting in a malformed packet error (Trying to fetch an unsigned integer with length 0). My question is, sh...'''
date = "2016-11-07T10:18:00Z"
lastmod = "2016-11-08T03:05:00Z"
weight = 57081
keywords = [ "dissector", "custom" ]
aliases = [ "/questions/57081" ]
osqa_answers = 1
osqa_accepted = false
+++

<div class="headNormal">

# [Custom dissector - Handling of zero length in proto\_tree\_add\_item](/questions/57081/custom-dissector-handling-of-zero-length-in-proto_tree_add_item)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-57081-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-57081-score" class="post-score" title="current number of votes">0</div><span id="post-57081-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span> <span id="favorite-mark" class="ajax-command favorite-mark" rel="nofollow" title="mark/unmark this question as favorite (click again to cancel)"> </span><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>Hi,</p><p>I have a question regarding the usage of <code>proto_tree_add_item()</code> in a custom dissector. I encountered a scenario wherein the length parameter to the <code>proto_tree_add_item()</code> function was zero resulting in a malformed packet error (Trying to fetch an unsigned integer with length 0).</p><p>My question is, should the custom dissector always handle such scenarios (length 0 or -1) before calling the <code>proto_tree_add_item()</code> function? Or is there some other way to handle such cases?</p><p>Any help is greatly appreciated! Thanks!</p></div><div id="question-tags" class="tags-container tags"><span class="post-tag tag-link-dissector" rel="tag" title="see questions tagged &#39;dissector&#39;">dissector</span> <span class="post-tag tag-link-custom" rel="tag" title="see questions tagged &#39;custom&#39;">custom</span></div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>07 Nov '16, 10:18</strong></p><img src="https://secure.gravatar.com/avatar/70baba446202981a08e25a49438b4161?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="sherlock_000&#39;s gravatar image" /><p><span>sherlock_000</span><br />
<span class="score" title="11 reputation points">11</span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="5 badges"><span class="silver">●</span><span class="badgecount">5</span></span><span title="8 badges"><span class="bronze">●</span><span class="badgecount">8</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="sherlock_000 has no accepted answers">0%</span></p></div><div class="post-update-info post-update-info-edited"><p><span> edited <strong>07 Nov '16, 10:47</strong> </span></p></div></div><div id="comments-container-57081" class="comments-container"><span id="57084"></span><div id="comment-57084" class="comment"><div id="post-57084-score" class="comment-score"></div><div class="comment-text"><p>I don't get why the size of a source field which is assumed to represent an uint should ever be 0. Either the field in question is optional for the protocol, so it should not be added to the tree at all if it is not present in the tvb, or it is mandatory and thus expected at that point of the tvb, and in such case, the packet is really malformed if the tvb ends right before the expected occurrence of the field. Another possibility is that the field is optional and has no value, so its type is not uint.</p><p>Can you elaborate?</p></div><div id="comment-57084-info" class="comment-info"><span class="comment-age">(07 Nov '16, 11:01)</span> <span class="comment-user userinfo">sindy</span></div></div><span id="57087"></span><div id="comment-57087" class="comment"><div id="post-57087-score" class="comment-score"></div><div class="comment-text"><p>Or the field is variable-length and doesn't use the binary encoding that <code>proto_tree_add_item()</code> expects all FT_UINTn values to have, where there are, for octet-aligned values, somewhere between 1 and 8 octets of value. What <em>is</em> the encoding of the field in question?</p></div><div id="comment-57087-info" class="comment-info"><span class="comment-age">(07 Nov '16, 13:01)</span> <span class="comment-user userinfo">Guy Harris ♦♦</span></div></div><span id="57123"></span><div id="comment-57123" class="comment"><div id="post-57123-score" class="comment-score"></div><div class="comment-text"><p>Thanks Sindy and Guy Harris for your comments. As you mentioned, it might be better if I explain my situation with an example.</p><p>I have a UINT16 field (Little Endian encoding) which might be part of the protocol I am dissecting if the previous byte was set. The following is the logic I am trying to achieve</p><p>1) Check whether the previous byte was set</p><p>2) If so, check the number of remaining bytes in the tvb buffer</p><p>3) If the number of remaining bytes is less than 2 (as the field is UINT16), I would like to add the field to the tree with the remaining bytes and also add an Expert info to this field indicating that there is an issue with this.</p><p>The problem that I mentioned in my initial post occurs during step 3 when I try to add the field using <code>proto_tree_add_item()</code> with remaining bytes(in this case 0, because the tvb buffer did not have any bytes remaining). I was expecting the field to be created the same way as it works for a FT_BYTES field with length 0, but unfortunately malformed packet error occurs for the FT_UINT16 field.</p><p>So to go back to my initial question, should the dissector take care that at least 1 byte is available before calling <code>proto_tree_add_item</code> for a FT_UINTn field?</p></div><div id="comment-57123-info" class="comment-info"><span class="comment-age">(08 Nov '16, 00:44)</span> <span class="comment-user userinfo">sherlock_000</span></div></div><span id="57124"></span><div id="comment-57124" class="comment"><div id="post-57124-score" class="comment-score"></div><div class="comment-text"><p>What are the protocols over which this protocol runs?</p><p>In particular, does it run over a byte-stream protocol such as TCP or TLS-over-TCP, or does it run over a protocol that exposes packet boundaries to protocols running atop it?</p></div><div id="comment-57124-info" class="comment-info"><span class="comment-age">(08 Nov '16, 00:50)</span> <span class="comment-user userinfo">Guy Harris ♦♦</span></div></div><span id="57125"></span><div id="comment-57125" class="comment"><div id="post-57125-score" class="comment-score"></div><div class="comment-text"><p>It runs over either TCP or UDP</p></div><div id="comment-57125-info" class="comment-info"><span class="comment-age">(08 Nov '16, 00:50)</span> <span class="comment-user userinfo">sherlock_000</span></div></div><span id="57128"></span><div id="comment-57128" class="comment not_top_scorer"><div id="post-57128-score" class="comment-score"></div><div class="comment-text"><p>If it runs over UDP, does a single packet for the protocol correspond to a single UDP packet, so that you don't have multiple packets for the protocol in a single UDP packet and you don't have multiple UDP packets being reassembled into a single packet for the protocol?</p><p>If it runs over TCP, there has to be <em>some</em> mechanism to indicate where the packet boundaries are in the byte stream; does each packet begin with a length field that indicates how long the packet is, or is some other mechanism used?</p></div><div id="comment-57128-info" class="comment-info"><span class="comment-age">(08 Nov '16, 00:55)</span> <span class="comment-user userinfo">Guy Harris ♦♦</span></div></div><span id="57134"></span><div id="comment-57134" class="comment not_top_scorer"><div id="post-57134-score" class="comment-score"></div><div class="comment-text"><p>A single TCP/UDP payload might contain more than one packet of the custom protocol. As of now, there is no reassembly of multiple TCP/UDP packets necessary, but it might be helpful for me to know how to handle such cases too.</p><p>To your question regarding the length of the protocol packet, yes, there is a header within each protocol packet that has the length information of that particular packet. There could be cases(rare) wherein the length field might be wrong. Will that cause a problem?</p></div><div id="comment-57134-info" class="comment-info"><span class="comment-age">(08 Nov '16, 01:06)</span> <span class="comment-user userinfo">sherlock_000</span></div></div></div><div id="comment-tools-57081" class="comment-tools"><span class="comments-showing"> showing 5 of 7 </span> <a href="#" class="show-all-comments-link">show 2 more comments</a></div><div class="clear"></div><div id="comment-57081-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="57136"></span>

<div id="answer-container-57136" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-57136-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-57136-score" class="post-score" title="current number of votes">0</div><span id="post-57136-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span></div></td><td><div class="item-right"><div class="answer-body"><p>OK, so if the flag byte has a non-zero value, but there are fewer than 2 bytes left in the packet after it, that probably means that the protocol's packet is <em>not</em> entirely contained within the TCP segment (or UDP packet?), so that you will be able to correctly dissect the 2-byte integer field only if you do reassembly.</p><p>I.e., yes, there <strong><em>IS</em></strong> reassembly of multiple TCP packets necessary to solve your problem, and, if packets for the custom protocol can be split between UDP packets, there is also reassembly of multiple UDP packets necessary to solve your problem.</p><p>For TCP, use <code>tcp_dissect_pdus()</code>; see section 2.7.1 of <a href="https://code.wireshark.org/review/gitweb?p=wireshark.git;a=blob;f=doc/README.dissector;h=3c6ba01adb0219e5a24fb8c9442c60c360b50c57;hb=HEAD">the README.dissector file</a>.</p><p>For UDP, if there are never packets for the custom protocol that are split between UDP packets - i.e., a single UDP packet can contain more than one packet for the custom protocol, but no packet for the custom protocol is ever split between UDP packets - you can just have a loop that processes the UDP payload a packet at a time. If there <em>are</em> packets for the custom protocol that are split between UDP packets, then you'll have to write your own reassembly code.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>08 Nov '16, 01:27</strong></p><img src="https://secure.gravatar.com/avatar/f93de7000747ab5efb5acd3034b2ebd7?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Guy%20Harris&#39;s gravatar image" /><p><span>Guy Harris ♦♦</span><br />
<span class="score" title="17443 reputation points"><span>17.4k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="35 badges"><span class="silver">●</span><span class="badgecount">35</span></span><span title="196 badges"><span class="bronze">●</span><span class="badgecount">196</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Guy Harris has 216 accepted answers">19%</span></p></div></div><div id="comments-container-57136" class="comments-container"><span id="57143"></span><div id="comment-57143" class="comment"><div id="post-57143-score" class="comment-score"></div><div class="comment-text"><p>Thanks for the answer. I am currently having a loop similar to what you mentioned to handle multiple packets within a single TCP/UDP payload.</p><p>The reason I didn't use <code>tcp_dissect_pdus()</code> is because there might be packets where the message length might be incorrect. What will happen if the packet length extracted from the header is invalid(for e.g. higher than the actual reported length, or smaller than the length expected for the current protocol packet)? How will <code>tcp_dissect_pdus()</code> react in such a case?</p><p>You had also mentioned that if there are fewer than 2 bytes left in the overall UDP packet, there could be a possibility of reassembly. But I am also interested in a situation when the protocol was not implemented properly in a device and hence that optional field of 2 bytes was not sent. I was thinking I could add the field using <code>proto_tree_add_item</code> and then include the expert info to that field. Is it never possible for a dissector to add a FT_UINTn field with 0 bytes?</p></div><div id="comment-57143-info" class="comment-info"><span class="comment-age">(08 Nov '16, 01:48)</span> <span class="comment-user userinfo">sherlock_000</span></div></div><span id="57144"></span><div id="comment-57144" class="comment"><div id="post-57144-score" class="comment-score">1</div><div class="comment-text"><blockquote><p>What will happen if the packet length extracted from the header is invalid(for e.g. higher than the actual reported length, or smaller than the length expected for the current protocol packet)?</p></blockquote><p>Then your protocol won't actually <em>work</em>, and if Wireshark mis-dissects it, that's a <em>feature</em> not a bug! It will show what the receiving machine will <em>think</em> the packet will look like.</p><blockquote><p>You had also mentioned that if there are fewer than 2 bytes left in the overall UDP packet, there could be a possibility of reassembly.</p></blockquote><p>No, I said that if the flag byte means "there is a 2-byte integer following the flag byte", but there aren't 2 bytes remaining after that in the TCP segment or UDP datagram, then the packet for your protocol is malformed.</p><blockquote><p>But I am also interested in a situation when the protocol was not implemented properly in a device and hence that optional field of 2 bytes was not sent.</p></blockquote><p>Then, for TCP, Wireshark will try to grab the next 2 bytes from the data stream and add it to the packet, and dissect that. If that doesn't look right, that's an excellent indication that the sending machine is buggy and needs to be fixed, because the receiving machine will <em>also</em> try to grab the next to bytes from the data stream and treat it as part of the packet.</p><blockquote><p>Is it never possible for a dissector to add a FT_UINTn field with 0 bytes?</p></blockquote><p>No, because that would not make any sense at all. An FT_UINT16 field with 1 byte is rarely used - if the field is always supposed to be 1 byte long, that'd be an FT_UINT8 field, and if it's 1 byte in some packets and 2 bytes in other packets, it's convenient to use FT_UINT16 (although the main difference between FT_UINT8 and FT_UINT16 is whether, when displayed in hex or octal, it shows 8 or 16 bits worth of hex or octal digits - for decimal, we don't provide leading zeroes, so that doesn't make a difference).</p><p>But at least there <em>is</em> a value if there's only 1 byte. With 0 bytes, there are no bytes to <em>provide</em> a value, so there is no possible way in which an FT_UINTn field with 0 bytes could be sanely implemented.</p><p>And, if you really don't want to do reassembly, because the senders of these packets are developed by not-very-competent programmers and they screw up the packet length <em>that</em> much, then, if there aren't 2 bytes present, you should just put up an expert info saying "either this packet crosses TCP segment boundaries or the person who developed the code that sent it needs adult supervision".</p></div><div id="comment-57144-info" class="comment-info"><span class="comment-age">(08 Nov '16, 02:15)</span> <span class="comment-user userinfo">Guy Harris ♦♦</span></div></div><span id="57146"></span><div id="comment-57146" class="comment"><div id="post-57146-score" class="comment-score"></div><div class="comment-text"><p>Thanks a lot for your detailed explanation.</p><p>When I asked the question, I was under the impression that a field with FT_BYTES or FT_UINTn should behave in a same way when the length parameter is 0. Because I remember seeing a FT_BYTES field displaying <code>&lt;MISSING&gt;</code> when the length parameter for <code>proto_tree_add_item()</code> was 0. So I was expecting the same behavior for a FT_UINTn field too.</p></div><div id="comment-57146-info" class="comment-info"><span class="comment-age">(08 Nov '16, 03:05)</span> <span class="comment-user userinfo">sherlock_000</span></div></div></div><div id="comment-tools-57136" class="comment-tools"></div><div class="clear"></div><div id="comment-57136-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

