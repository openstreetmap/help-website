+++
type = "question"
title = "Multiple dissectors per protocol"
description = '''I would like rework the dissector for Google Protobuf found under the name &quot;protobuf-wireshark-runtime-0.1.tar.gz&quot; here: I cannot promise that I can finish the work for upstream, but I will try :-) Google Protobuf is not a protocol itself, it&#x27;s more a generator for different protocols (message types...'''
date = "2016-12-13T22:25:00Z"
lastmod = "2016-12-16T15:33:00Z"
weight = 58064
keywords = [ "google", "protocol", "protobuf", "buffers" ]
aliases = [ "/questions/58064" ]
osqa_answers = 3
osqa_accepted = false
+++

<div class="headNormal">

# [Multiple dissectors per protocol](/questions/58064/multiple-dissectors-per-protocol)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-58064-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-58064-score" class="post-score" title="current number of votes">0</div><span id="post-58064-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span> <span id="favorite-mark" class="ajax-command favorite-mark" rel="nofollow" title="mark/unmark this question as favorite (click again to cancel)"> </span><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>I would like rework the dissector for Google Protobuf found under the name "protobuf-wireshark-runtime-0.1.tar.gz" <a href="https://code.google.com/archive/p/protobuf-wireshark/">here</a>:</p><p>I cannot promise that I can finish the work for upstream, but I will try :-)</p><p>Google Protobuf is not a protocol itself, it's more a generator for different protocols (<em>message types</em> in protobuf). Protobuf uses text files called <em>protofiles</em> which contain the definition for one or more message types. I think this may be comparable to Corba IDL or SOAP.</p><p>Although encoded protobuf messages are somehow self contained (tags, length, wire type), they contain absolutely no information about the top level message type. So the message type must be known by wireshark (e.g. user defined mapping between TCP/UDP port numbers and the message type).</p><p>As as first step I've defined preferences for the protobuf protocol so that the user can specify multiple (UAT) entries containing protofiles and the name of the messages types.</p><p><strong>Main question:</strong></p><p>How shall I implement the dissection of the different message types in wireshark?</p><p><strong>Alternative 1:</strong></p><p>Instantiate as much dissectors as there are different message types. Let wireshark dispatch the frame to the corresponding dissector (e.g. by TCP/UDP port number / decode as... dialog).</p><p><strong>Questions regarding alternative 1:</strong></p><ol><li>Can I create multiple dissectors "inside" one protocol?</li><li>Can I pass individual <em>this pointers</em> (e.g. void *) to the dissectors dissect function?</li><li>dissector_add_for_decode_as() seems not to allow registering multiple dissectors for the same protocol. Am I correct?</li></ol><p><strong>Alternative 2:</strong></p><p>Create only one dissector and differentiate between the different message type inside the dissector function.</p><p><strong>Questions regarding alternative 2:</strong></p><ol><li>In the dissect function, I need information about the lower layers (e.g. TCP/UDP port number) in order dissect the message correctly (choose the right message type). How can I get these information?</li><li>Can I also get information about the lower layers if the message has not been received by other protocols than TCP or UDP (e.g. HDLC)?</li></ol></div><div id="question-tags" class="tags-container tags"><span class="post-tag tag-link-google" rel="tag" title="see questions tagged &#39;google&#39;">google</span> <span class="post-tag tag-link-protocol" rel="tag" title="see questions tagged &#39;protocol&#39;">protocol</span> <span class="post-tag tag-link-protobuf" rel="tag" title="see questions tagged &#39;protobuf&#39;">protobuf</span> <span class="post-tag tag-link-buffers" rel="tag" title="see questions tagged &#39;buffers&#39;">buffers</span></div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>13 Dec '16, 22:25</strong></p><img src="https://secure.gravatar.com/avatar/65f16ed12a561d0357e35088b02f1bc5?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Christian%20Eggers&#39;s gravatar image" /><p><span>Christian Eg...</span><br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="2 badges"><span class="bronze">●</span><span class="badgecount">2</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Christian Eggers has no accepted answers">0%</span></p></div></div><div id="comments-container-58064" class="comments-container"><span id="58070"></span><div id="comment-58070" class="comment"><div id="post-58070-score" class="comment-score"></div><div class="comment-text"><p>Hi, Disclaimer I don't know much about googles protocol buffers.</p><p>One way of looking at it is that Google protocol buffer provides you with the means of easily design a protocol which means that you actually have different protocols using the same frame work. E.G you need a dissector per protocol. It might be possible to use one dissector with configuration files or data structures for the protocol in question in which case there should be preference settings saying decode port xx as protocol yy or something along those lines or have a script creating a dissector from input files like asn1 based dissectors do.</p></div><div id="comment-58070-info" class="comment-info"><span class="comment-age">(14 Dec '16, 03:45)</span> <span class="comment-user userinfo">Anders ♦</span></div></div></div><div id="comment-tools-58064" class="comment-tools"></div><div class="clear"></div><div id="comment-58064-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

3 Answers:

</div>

</div>

<span id="58076"></span>

<div id="answer-container-58076" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-58076-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-58076-score" class="post-score" title="current number of votes">0</div><span id="post-58076-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span></div></td><td><div class="item-right"><div class="answer-body"><p><a href="http://wsgd.free.fr/">Wireshark Generic Dissector</a> (WSGD) uses a couple of text files to indicate what to dissect and how to format the dissection, a similar approach could be used for Google Protocol Buffers.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>14 Dec '16, 05:38</strong></p><img src="https://secure.gravatar.com/avatar/d2a7e24ca66604c749c7c88c1da8ff78?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="grahamb&#39;s gravatar image" /><p><span>grahamb ♦</span><br />
<span class="score" title="19834 reputation points"><span>19.8k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="30 badges"><span class="silver">●</span><span class="badgecount">30</span></span><span title="206 badges"><span class="bronze">●</span><span class="badgecount">206</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="grahamb has 274 accepted answers">22%</span></p></div></div><div id="comments-container-58076" class="comments-container"><span id="58095"></span><div id="comment-58095" class="comment"><div id="post-58095-score" class="comment-score"></div><div class="comment-text"><p>Thank you for pointing to something which is similar to my purpose. It looks like WSGD registers exactly one protocol and one dissector per WSDG file.</p><p>So lets think about alternative 3: Register one fixed protocol as a placeholder where the use can configure preferences for protobuf. I will check whether dynamic registration and deregistration of protocols is possible or the user has to restart wireshark after altering the list of protobuf message types.</p></div><div id="comment-58095-info" class="comment-info"><span class="comment-age">(14 Dec '16, 11:06)</span> <span class="comment-user userinfo">Christian Eg...</span></div></div></div><div id="comment-tools-58076" class="comment-tools"></div><div class="clear"></div><div id="comment-58076-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<span id="58096"></span>

<div id="answer-container-58096" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-58096-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-58096-score" class="post-score" title="current number of votes">0</div><span id="post-58096-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span></div></td><td><div class="item-right"><div class="answer-body"><p>Similar (I think) to Anders' suggestion, I think the right answer is probably close to Alternative 2 but slightly different (call it Alternative 3): one dissector per protocol where a protocol is effectively a collection of related messages.</p><p>To answer your Alternative 2 questions: if your dissector is called based on a matching uint field (e.g., the TCP port number) then <code>pinfo-&gt;match_uint</code> will be set to the uint value. This works for dissectors registered for specific ports but I'm not sure if this will include Decode-as cases.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>14 Dec '16, 11:24</strong></p><img src="https://secure.gravatar.com/avatar/e0564001bb7deb960d5d9d9c1e0ba074?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="JeffMorriss&#39;s gravatar image" /><p><span>JeffMorriss ♦</span><br />
<span class="score" title="6219 reputation points"><span>6.2k</span></span><span title="5 badges"><span class="silver">●</span><span class="badgecount">5</span></span><span title="72 badges"><span class="bronze">●</span><span class="badgecount">72</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="JeffMorriss has 103 accepted answers">27%</span></p></div></div><div id="comments-container-58096" class="comments-container"><span id="58100"></span><div id="comment-58100" class="comment"><div id="post-58100-score" class="comment-score"></div><div class="comment-text"><p>Most protocols have either a fixed (iana assigned) port number or one particular TCP OR UDP port number can be configured in the protocols preferences.</p><p>In the case of Google Protocol Buffers I don't like the scheme because ... ... protocol buffers are not a protocol itself, so they have no standard port numbers. ... protobuf messages may be sent via TCP, UDP or something completely different (e.g. HDLC or raw ethernet frames). ... I don't see a way to let the user configure this various possibilities via the protocols preferences page</p><p>I would prefer when exclusively the "Decode As..." dialog can used to select protobuf as the dissector for data using a particular transport. Unfortunately it seems that I'll have to call dissector_add_for_decode_as() for each dissector table individually.</p><p>In case my dissector is called this way, pinfo-&gt;match_uint may contain something like the port or protocol number, but this is not useful for me because if don't let the user configure the port number via the protocol preferences page, I also don't have any relation between pinfo-&gt;match_uint and the assigned protobuf message type (did anybody understand my problem?).</p><p>Conclusion: I think that alternative 2 is not an ideal option. If multiple dissectors per protocol are not possible, I will have to register multiple protocols.</p></div><div id="comment-58100-info" class="comment-info"><span class="comment-age">(14 Dec '16, 12:16)</span> <span class="comment-user userinfo">Christian Eg...</span></div></div><span id="58102"></span><div id="comment-58102" class="comment"><div id="post-58102-score" class="comment-score"></div><div class="comment-text"><p>It's true that protocol buffers aren't a protocol themselves but generally people are implementing a protocol using protocol buffers (i.e., they make a protocol with N message types whose formatting happens to be the protocol buffers format). When they are implementing a protocol they often (in my experience) do things like choose a transport and a (probably not IANA registered) port. IOW I don't think just knowing the port number will tell you the message type. But it could tell you what group of message types the message will be from.</p><p>If your dissector had a configuration file or UAT which allowed the user to specify the name of the protocol, the transport, the "port" (or equivalent), and the path to the proto file then you could establish a (dynamically configured) dissector for that protocol(**). If the port wasn't specified (or was 0) then the "protocol" would only be available via Decode-As.</p><p>(**) Actually I think I'm starting to remember that the .proto file doesn't give you enough information. You need the "compiled" output to match the names to the numbers. Or something like that...</p></div><div id="comment-58102-info" class="comment-info"><span class="comment-age">(14 Dec '16, 12:39)</span> <span class="comment-user userinfo">JeffMorriss ♦</span></div></div><span id="58107"></span><div id="comment-58107" class="comment"><div id="post-58107-score" class="comment-score"></div><div class="comment-text"><p>Perhaps I think too complicated, but how can I let the user choose a transport via UAT? Do I have to use UAT_VS_DEF() and code my own enum with transports which I think may be suitable for protobuf together with an additional uint field?</p><p>Option 1: Offer a list of transports I personally use for protobuf --&gt; Users who use another transport than me, will have to change the code.</p><p>Option 2: Make protobuf available for ALL transports. No idea how to do this. In order to be available in "Decode As...", I would have to call dissector_add_for_decode_as() for ALL dissector tables. Not sure whether this makes sense.</p><p>Both options depend on that my preferred/all dissector tables use an uint for matching the higher layer protocol.</p><p>Decoding protobuf itself (by giving a textual proto file) is already solved in the original protobuf-runtime implementation. The protobuf definition is "compiled" on the fly inside wireshark and dissection is done by a protobuf feature called "reflection".</p></div><div id="comment-58107-info" class="comment-info"><span class="comment-age">(14 Dec '16, 13:28)</span> <span class="comment-user userinfo">Christian Eg...</span></div></div><span id="58111"></span><div id="comment-58111" class="comment"><div id="post-58111-score" class="comment-score"></div><div class="comment-text"><p>So as an example if you "told" the Tcp dissector to decode port x as protocol buffer and had a preference in the protocol buffer dissector to decode to port x as protocol type Y and loaded the protocol description for that port. That would work? In that case use a unit dissector table in the protocol buffer dissector per transport type and dynamically register a dissector with the Def there.</p></div><div id="comment-58111-info" class="comment-info"><span class="comment-age">(14 Dec '16, 14:32)</span> <span class="comment-user userinfo">Anders ♦</span></div></div><span id="58136"></span><div id="comment-58136" class="comment"><div id="post-58136-score" class="comment-score"></div><div class="comment-text"><p>I'm not too familiar with UATs but I would think there would be a way to do it with an enum.</p><p>Personally I don't think it's realistic to support ALL transports. Maybe there is a way to do it gracefully but I think trying to register for all dissector tables isn't very nice.</p><p>You'll probably cover 99% of use cases by doing TCP and UDP and another 0.9% by adding SCTP. And anyway it's Open Source software: if someone actually wants to run protobufs over, say, Bluetooth, they can always add support when they find the need. And Wireshark doesn't get bloated with a bunch of stuff that nobody actually uses.</p></div><div id="comment-58136-info" class="comment-info"><span class="comment-age">(15 Dec '16, 05:59)</span> <span class="comment-user userinfo">JeffMorriss ♦</span></div></div></div><div id="comment-tools-58096" class="comment-tools"></div><div class="clear"></div><div id="comment-58096-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<span id="58140"></span>

<div id="answer-container-58140" class="answer answered-by-owner">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-58140-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-58140-score" class="post-score" title="current number of votes">0</div><span id="post-58140-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span></div></td><td><div class="item-right"><div class="answer-body"><p>Thanks to all who gave information about this topic. I will try to summarize:</p><h1 id="similar-work">1. Similar work</h1><p><a href="http://wsgd.free.fr/">Wireshark Generic Dissector</a> does something similar. At startup it scans particular directories for configuration files and instantiates as much protocols+dissectors as there are configuration files.</p><h1 id="multiple-dissectors-per-protocol-1">2. Multiple dissectors per protocol?</h1><p>As nobody wrote something else, I assume that it is only possible to register one dissector per protocol. If I want to register more (e.g. dynamically) dissectors, I'll have to register them together with an individual protocol.</p><h1 id="one-or-multiple-dissectors-at-all">3. One or multiple dissectors at all?</h1><p>One protofile usually contains a "tree" of message type definitions. My intention for "alternative 1" was to have one dissector per "tree" of message types. So I think I agree to what JeffMorriss answered.</p><p>It is most likely that I will register one "static" protocol+dissector for protobuf, which is able to perform "raw decoding" which means that no protofile is needed and only "raw" tag numbers + values can be shown in the proto tree.</p><p>This "static" protocol will have a UAT in its preferences page, which allows the user to define further "dynamic" protocols (in contrast to let the user create configuration files as WSGD does).</p><h1 id="registration-in-dissector-tables">4. Registration in dissector tables?</h1><p>Nobody wrote that it is usual/acceptable to register a dissector for all transport protocols. So the "normal" way is to add a <em>enum preference</em> with a selection of pre-defined transport names and a <em>range preference</em> for the (uint) port/protocol number.</p><h1 id="remaining-issues">Remaining issues</h1><h2 id="dynamic-deregistration-is-not-possible.">1. Dynamic deregistration is not possible.</h2><p>At least <code>proto_deregister_protocol()</code>, <code>prefs_deregister_protocol()</code>, <code>uat_destroy()</code> and <code>deregister_dissector()</code> are not exported to wireshark plugins. So there seems to be no possibility to remove "dynamically" instantiated protocols after the user removed them from the preferences UAT.</p><p>Because of this, I would also register "dynamic" protocol only on startup, so the user has to restart Wireshark after altering the list of dynamic protocols.</p><h2 id="missing-this-pointer-in-dissector_t">2. Missing <em>this</em> pointer in <code>dissector_t</code></h2><p>Most C functions which use a pointer to a user defined callback let also define a <code>void *</code> pointer which will usually be passed as first/last parameter when to callback is executed. When <code>call_dissector_through_handle()</code> runs a dissector, nothing like this is provided (only <code>pinfo-&gt;current_proto</code> seems to contain something useful, the last parameter (void *) is used for something different by <code>call_dissector_with_data()</code>).</p><p>For dynamically created dissectors this can be a difficult challenge because usually they all share the same dissector callback. WSGD creates a fixed "pool" of callback functions so there is an arbitrary limit on the number of dynamic dissectors the user can define. A similar solution I have found <a href="http://p-nand-q.com/programming/cplusplus/using_member_functions_with_c_function_pointers.html">here</a>, but generally the lack of a <em>this pointer</em> makes things more complicated than necessary.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>15 Dec '16, 10:43</strong></p><img src="https://secure.gravatar.com/avatar/65f16ed12a561d0357e35088b02f1bc5?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Christian%20Eggers&#39;s gravatar image" /><p><span>Christian Eg...</span><br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="2 badges"><span class="bronze">●</span><span class="badgecount">2</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Christian Eggers has no accepted answers">0%</span></p></div></div><div id="comments-container-58140" class="comments-container"><span id="58141"></span><div id="comment-58141" class="comment"><div id="post-58141-score" class="comment-score"></div><div class="comment-text"><ol><li>There are two solutions: 1) The preferred is to not write your dissector as a plugin but rather as a built-in dissector (in <code>epan/dissectors/</code>); in fact we generally don't accept new plugins. The main exception to this rule is for dissectors that end up requiring lots of files. 2) The second option (if there are good reasons for it to be a plugin) is to submit a patch that exports those APIs so they can be used by plugins.</li><li>The old way (before any dissector calls had <code>void *</code>'s) was to use <code>pinfo-&gt;private_data</code>. That can be mildly tricky and painful (especially with regards to restoring the old <code>private_data</code> after an exception was thrown) but it can be made to work. You could probably do that if adding <code>void *</code>'s to the existing stuff isn't feasible.</li></ol></div><div id="comment-58141-info" class="comment-info"><span class="comment-age">(15 Dec '16, 11:29)</span> <span class="comment-user userinfo">JeffMorriss ♦</span></div></div><span id="58147"></span><div id="comment-58147" class="comment"><div id="post-58147-score" class="comment-score"></div><div class="comment-text"><ol><li><p>This is clear for me. I would like to start with a plugin and submit a built-in later. For the built-in, I'll try to (de)register the new protocols immediately in the apply callback.</p></li><li><p>How can I influence what Wireshark passes to my dissector function via the void* pointer when it is directly called by wireshark (e.g. as a result of dissector_table match)? I could only find many cases where NULL is passed. I would like to specify the value directly after registering the protocol / dissector.</p></li></ol></div><div id="comment-58147-info" class="comment-info"><span class="comment-age">(15 Dec '16, 14:06)</span> <span class="comment-user userinfo">Christian Eg...</span></div></div><span id="58173"></span><div id="comment-58173" class="comment"><div id="post-58173-score" class="comment-score"></div><div class="comment-text"><ol><li>So you could always make the necessary APIs public/exported to plugins during development (and drop that part of the change when it's time to submit it).</li><li>(I assume you mean the <code>void *</code> in the top-level dissector function.) You can't. That's why I was suggesting using <code>pinfo-&gt;private_data</code> instead. Or maybe I'm mis-understanding your question.</li></ol></div><div id="comment-58173-info" class="comment-info"><span class="comment-age">(16 Dec '16, 11:36)</span> <span class="comment-user userinfo">JeffMorriss ♦</span></div></div><span id="58176"></span><div id="comment-58176" class="comment"><div id="post-58176-score" class="comment-score"></div><div class="comment-text"><p>I would suggest doing the general dissector first and submit that with sample traces. Them it would be easier to discuss the next step.</p></div><div id="comment-58176-info" class="comment-info"><span class="comment-age">(16 Dec '16, 15:33)</span> <span class="comment-user userinfo">Anders ♦</span></div></div></div><div id="comment-tools-58140" class="comment-tools"></div><div class="clear"></div><div id="comment-58140-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

