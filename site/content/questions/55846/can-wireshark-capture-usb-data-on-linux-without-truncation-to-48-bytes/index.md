+++
type = "question"
title = "Can Wireshark capture USB data on Linux without truncation to 48 bytes?"
description = '''As per the title: can Wireshark capture USB data without truncation to 48 bytes? I understand that this is a limitation of usbmon - whether it&#x27;s a hard limit that can never be breached, I don&#x27;t know, hence the question. But truncating the data to 48 bytes renders the capture useless for my present p...'''
date = "2016-09-26T08:34:00Z"
lastmod = "2016-10-14T14:29:00Z"
weight = 55846
keywords = [ "usb", "truncate", "linux" ]
aliases = [ "/questions/55846" ]
osqa_answers = 0
osqa_accepted = false
+++

<div class="headNormal">

# [Can Wireshark capture USB data on Linux without truncation to 48 bytes?](/questions/55846/can-wireshark-capture-usb-data-on-linux-without-truncation-to-48-bytes)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-55846-score" class="post-score" title="current number of votes">0</div><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>As per the title: can Wireshark capture USB data without truncation to 48 bytes?</p><p>I understand that this is a limitation of usbmon - whether it's a hard limit that can never be breached, I don't know, hence the question. But truncating the data to 48 bytes renders the capture useless for my present purposes.</p></div><div id="question-tags" class="tags-container tags">usb truncate linux</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>26 Sep '16, 08:34</strong></p><img src="https://secure.gravatar.com/avatar/cd46c2b5d0039a8d23281c5490b2ebe1?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="davehigton&#39;s gravatar image" /><p>davehigton<br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="4 badges"><span class="bronze">●</span><span class="badgecount">4</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="davehigton has no accepted answers">0%</span></p></div><div class="post-update-info post-update-info-edited"><p>edited 26 Sep '16, 13:36</p><img src="https://secure.gravatar.com/avatar/f93de7000747ab5efb5acd3034b2ebd7?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Guy%20Harris&#39;s gravatar image" /><p>Guy Harris ♦♦<br />
<span class="score" title="17443 reputation points"><span>17.4k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="35 badges"><span class="silver">●</span><span class="badgecount">35</span></span><span title="196 badges"><span class="bronze">●</span><span class="badgecount">196</span></span></p></div></div><div id="comments-container-55846" class="comments-container"><span id="55866"></span><div id="comment-55866" class="comment"><div id="post-55866-score" class="comment-score"></div><div class="comment-text"><p>Can you be more specific regarding the kernel version, type of USB communication to be captured, the application used for capturing (<code>tcpdump</code>, Wireshark/tshark capturing via <code>dumpcap</code>, anything else) etc.? The thing is that I am routinely using <code>usbmon</code> to capture USB traffic and I haven't encountered any frame truncations. But as I mainly concentrate on isochronous transfers, there may be an issue which is related to a particular transfer type which I haven't run into. <code>usbmon</code> declares to truncate the <strong>text</strong> output, but not the <strong>binary</strong> one which is used by <code>tcpdump</code> and/or <code>dumpcap</code> from the Wireshark suite. Also, I am using <code>tcpdump</code> to capture to a file at the source machines and then use Wireshark to analyze the saved files on my laptop, so there may be an unnoticed <code>dumpcap</code> issue.</p></div><div id="comment-55866-info" class="comment-info"><span class="comment-age">(26 Sep '16, 10:40)</span> sindy</div></div><span id="55875"></span><div id="comment-55875" class="comment"><div id="post-55875-score" class="comment-score"></div><div class="comment-text"><p>To quote <a href="https://github.com/torvalds/linux/blob/master/Documentation/usb/usbmon.txt">the usbmon documentation</a>:</p><blockquote><p>These events can be received from a character device by reading with read(2), with an ioctl(2), or by accessing the buffer with mmap. However, read(2) only returns first 48 bytes for compatibility reasons.</p></blockquote><p>If your kernel and libpcap support memory-mapped access for usbmon ("accessing the buffer with mmap"), there is no 48-byte truncation limit. That's why we need to know the kernel version <em>and</em> the libpcap version.</p></div><div id="comment-55875-info" class="comment-info"><span class="comment-age">(26 Sep '16, 13:38)</span> Guy Harris ♦♦</div></div><span id="55931"></span><div id="comment-55931" class="comment"><div id="post-55931-score" class="comment-score"></div><div class="comment-text"><p>Kernel is 4.4.0-38-generic; it's a fully up to date Ubuntu 16.04 LTS 64 bit OS.</p><p>Type of USB communication to be captured: even the traffic from a keyboard is sometimes truncated, but the real killer is traffic with a Bluetooth dongle, where packets frequently are in the region of 256 bytes.</p><p>Capture is directly with Wireshark after selecting the usbmon2 interface. I'm not running separate capture and analysis sessions.</p><p>libpcap is 1.7.4, tcpdump is 4.7.4, but I am not aware of how what I'm doing interacts with either of them.</p></div><div id="comment-55931-info" class="comment-info"><span class="comment-age">(27 Sep '16, 13:21)</span> davehigton</div></div><span id="55932"></span><div id="comment-55932" class="comment"><div id="post-55932-score" class="comment-score"></div><div class="comment-text"><blockquote><p>libpcap is 1.7.4, tcpdump is 4.7.4, but I am not aware of how what I'm doing interacts with either of them.</p></blockquote><p>As you start the capture from Wireshark, you use <code>libpcap</code> via <code>dumpcap</code> which is a process that Wireshark spawns for the actual capturing and reads its output. You do not use <code>tcpdump</code> at all.</p><blockquote><p>even the traffic from a keyboard is sometimes truncated, but the real killer is traffic with a Bluetooth dongle, where packets frequently are in the region of 256 bytes.</p></blockquote><p>Well, my question was related to the type of transfers (isochronous, interrupt, bulk, control) which are affected. But what you just wrote sounds to me as if only some of the URBs are truncated ("the traffic from a keyboard is <strong>sometimes</strong> truncated") and some are not even though larger than 48 bytes. Is this a correct understanding or it is just that some URBs from the keyboard are smaller than 48 bytes and thus are not truncated?</p><p>Just to be sure, can you capture some USB traffic using <code>tcpdump -i usbmon -s 0 -w tcpdump_usb_test.pcap</code>, press <code>Ctrl-C</code> when done, and then check whether the USBs in this file (<code>tcpdump_usb_test.pcap</code>) are also truncated if you open it using Wireshark?</p></div><div id="comment-55932-info" class="comment-info"><span class="comment-age">(27 Sep '16, 13:40)</span> sindy</div></div><span id="56044"></span><div id="comment-56044" class="comment"><div id="post-56044-score" class="comment-score"></div><div class="comment-text"><p>Firstly, I apologise for taking so long to respond.</p><blockquote><p>Well, my question was related to the type of transfers (isochronous, interrupt, bulk, control) which are affected.</p></blockquote><p>Ah, I didn't understand, sorry.</p><blockquote><p>Is this a correct understanding or it is just that some URBs from the keyboard are smaller than 48 bytes and thus are not truncated?</p></blockquote><p>Nothing in the capture exceeds 48 bytes; anything that had more than 48 bytes on the wire is truncated. Some packets only have 48 bytes on the wire and therefore are not truncated. My apologies for being unclear.</p><blockquote><p><code>tcpdump -i usbmon -s 0 -w tcpdump_usb_test.pcap</code></p></blockquote><p>Slightly modified - needs sudo, also needs to be usbmon2 rather than just usbmon, but this capture is NOT truncated.</p><p>So thank you for at least giving me a work-round.</p><p>Is it possible to make live capture-and-display work the same way?</p></div><div id="comment-56044-info" class="comment-info"><span class="comment-age">(01 Oct '16, 11:58)</span> davehigton</div></div><span id="56047"></span><div id="comment-56047" class="comment not_top_scorer"><div id="post-56047-score" class="comment-score"></div><div class="comment-text"><blockquote><p>needs to be <code>usbmon2</code> rather than just <code>usbmon</code></p></blockquote><p>that's true if you need to reduce the amount of captured data and system load, as use of <code>usbmon</code> causes traffic from all root hubs to be captured, while use of <code>usbmon2</code> causes only traffic from root hub 2 to be captured.</p><blockquote><p>Is it possible to make live capture-and-display work the same way?</p></blockquote><p>well, it is possible but not really convenient. You can tell tcpdump to write the output to a named pipe and let Wireshark read from the pipe, as described at <a href="https://wiki.wireshark.org/CaptureSetup/Pipes">the Capture Setup chapter of Wireshark's wiki</a>:</p><pre><code>mkfifo /tmp/my_pipe
wireshark -k -i /tmp/my_pipe &amp;
sudo tcpdump -i usbmon2 -s 0 -w /tmp/my_pipe &amp;</code></pre><p>But the difference in behaviour between tcpdump and Wireshark makes me wonder what version of Wireshark you are running? Have you compiled it from source, or has it come with your Ubuntu distribution?</p></div><div id="comment-56047-info" class="comment-info"><span class="comment-age">(01 Oct '16, 12:31)</span> sindy</div></div><span id="56063"></span><div id="comment-56063" class="comment not_top_scorer"><div id="post-56063-score" class="comment-score"></div><div class="comment-text"><blockquote><p>But the difference in behaviour between tcpdump and Wireshark makes me wonder what version of Wireshark you are running? Have you compiled it from source, or has it come with your Ubuntu distribution?</p></blockquote><p>You may well ask what version. Dash suggested it was the current stable version (2.0.2 something - this is Ubuntu 16.04), but Wireshark's Help About Wireshark said 1.12.8 (Git Rev Unknown from unknown).</p><p>I didn't compile it myself, and it isn't part of the Ubuntu distribution. I must have installed it from a download from the Wireshark downloads site. I did have a folder named Wireshark 1.12.8, which I have deleted.</p><p>Anyway, within the last few minutes I've attempted to remove Wireshark via apt-get, then install the current dev one (2.2.0 something) via apt-get. However, Help About Wireshark still says version 1.12.8, and the truncation issue when capturing from usbmon remains.</p><p>So, somewhat bizarrely, I can't be certain what version I'm running, as the information I have is contradictory.</p><p>Does Help About correctly identify Wireshark's version? If so, then it looks to me as if the removal process didn't work properly (and I would appreciate some pointers about removing it completely).</p></div><div id="comment-56063-info" class="comment-info"><span class="comment-age">(01 Oct '16, 14:45)</span> davehigton</div></div><span id="56064"></span><div id="comment-56064" class="comment not_top_scorer"><div id="post-56064-score" class="comment-score"></div><div class="comment-text"><p>Sorry - I must correct myself here. I am looking at a capture from the mouse. All packets are 52 bytes on the wire. All packets from host to device are truncated to 48 bytes; all packets from device to host have the full 52 bytes.</p></div><div id="comment-56064-info" class="comment-info"><span class="comment-age">(01 Oct '16, 15:03)</span> davehigton</div></div><span id="56065"></span><div id="comment-56065" class="comment not_top_scorer"><div id="post-56065-score" class="comment-score"></div><div class="comment-text"><p>Wireshark's Help About identifies the version of Wireshark that is displaying Help About.</p></div><div id="comment-56065-info" class="comment-info"><span class="comment-age">(01 Oct '16, 15:36)</span> grahamb ♦</div></div><span id="56066"></span><div id="comment-56066" class="comment not_top_scorer"><div id="post-56066-score" class="comment-score"></div><div class="comment-text"><p>Wireshark captures network traffic by running the dumpcap program, which is part of the Wireshark package; dumpcap uses libpcap, just as tcpdump does, to capture traffic.</p><p>This is why it's strange that tcpdump isn't truncating any packet but Wireshark - which means dumpcap - <em>is</em> truncating packets going from the host to the device.</p><p>Perhaps they're using different versions of libpcap.</p><p>What do the commands <code>which wireshark</code>, <code>which dumpcap</code>, and <code>which tcpdump</code> print?</p><p>What does the command <code>dumpcap -v</code> print (<em>all</em> of what it prints, not just the version of dumpcap itself)?</p><p>When you say "install the current dev one (2.2.0 something) via apt-get." what do you mean by "dev" in "current dev one"?</p></div><div id="comment-56066-info" class="comment-info"><span class="comment-age">(01 Oct '16, 23:25)</span> Guy Harris ♦♦</div></div><span id="56277"></span><div id="comment-56277" class="comment not_top_scorer"><div id="post-56277-score" class="comment-score"></div><div class="comment-text"><p>Apologies again for the long absence.</p><p>I had a zombie copy of Wireshark 1.12.8 that refused to die - whatever I installed, or even when I uninstalled it, 1.12.8 was still there.</p><p>I did kill it in the end. Now I've got 2.0.2 installed. Properly.</p><p>OK, does it capture truncated now?</p><p>I just tried capturing from usbmon2 and simply hitting the NumLock key several times. There are some pairs of lines for control out transactions. For each pair, the first has source as host and destination as 2.3.0, length 49. The packet details show 49 bytes on wire, 49 bytes captured, and I can recognise a control transaction with bmRequestType = 0x21, bRequest = 0x09, wValue = 0x0200, wIndex = 0x0000, wLength = 1 and one data byte (contents 0x01 when NumLock goes on, 0 when off). Good. The second of the pair has "[Packet size limited during capture]" in the Info column. Source is 2.3.0 and destination is host. The packet details say 49 bytes on wire, 48 bytes captured. But this is just an ACK for the out transaction, isn't it? Have any data been truncated? Or is this just a spurious error message from the dissector?</p></div><div id="comment-56277-info" class="comment-info"><span class="comment-age">(10 Oct '16, 03:25)</span> davehigton</div></div><span id="56278"></span><div id="comment-56278" class="comment not_top_scorer"><div id="post-56278-score" class="comment-score"></div><div class="comment-text"><p>Discrepancy between "on the wire" and "captured" size is normally not an issue of dissector, at least it would be an issue of the <code>frame</code> dissector, not the <code>usb</code> one. Both sizes are stored in the capture file.</p><p>Given the description of your activity, you should see two interrupt transfers per keypress (because the press sends one message and the release sends another one) plus one SEND STATUS (or something similar) for the change of NumLock indicator LED status. What you describe seems to be only the exchange related to LED control.</p><p>However, to properly dissect what you now see as generic "USB CONTROL OUT" as a USBHID message SEND STATUS, you need to have the capture running already when connecting the keyboard, because Wireshark chooses the right dissector based on information from the USB descriptors which are only transferred over the bus right after the device gets connected. It should be safe to disconnect the keyboard after starting the capture and connect it back, but if you have another keyboard, better keep the main one connected and use the second one for the experiments.</p><p>Not to be misunderstood - this won't change the interpretation of the frame size, it will only improve the dissection of the contents.</p><p>Also, please export that single weird frame into a separate capture file, publish that file somewhere in the web and place here a link to it. Cloudshark is popular here, but any file sharing service or your own web site will do. To be sure whether it is a dissection issue or a capture file issue, it needs a hex view to see what is written in the pcap file.</p><p>But as you said the issue didn't happen when you used tcpdump, please do exactly the same activity while capturing using tcpdump, and then do the same activity once again while using dumpcap (with the same parameters like tcpdump) to capture.</p><p>It's simply weird that the (probably) same libpcap on the same (definitely) usbmon should yield different results.</p></div><div id="comment-56278-info" class="comment-info"><span class="comment-age">(10 Oct '16, 04:25)</span> sindy</div></div><span id="56291"></span><div id="comment-56291" class="comment not_top_scorer"><div id="post-56291-score" class="comment-score"></div><div class="comment-text"><blockquote><p>The packet details say 49 bytes on wire, 48 bytes captured.</p></blockquote><p>So whatever capture mechanism is being used, in that case, is, in fact, truncating the capture at 48 bytes.</p><p>Does this happen if you use tcpdump to capture on <code>usbmon2</code> and save the packets a capture file with '-w', and then read the capture in Wireshark?</p><p>Does this happen if you capture on <code>usbmon2</code> in Wireshark?</p><p>What does <code>tcpdump -h</code> print? (The entire output, not just the tcpdump version number.)</p><p>What does <code>dumpcap -v</code> print? (The entire output, not just the dumpcap version number.)</p><p>What does</p><pre><code>ls -l `which tcpdump`</code></pre><p>print?</p><p>What does</p><pre><code>ls -l `which dumpcap`</code></pre><p>print?</p></div><div id="comment-56291-info" class="comment-info"><span class="comment-age">(10 Oct '16, 23:23)</span> Guy Harris ♦♦</div></div><span id="56353"></span><div id="comment-56353" class="comment not_top_scorer"><div id="post-56353-score" class="comment-score"></div><div class="comment-text"><blockquote><p>What does tcpdump -h print? (The entire output, not just the tcpdump version number.)</p></blockquote><pre><code>tcpdump version 4.7.4libpcap version 1.7.4
OpenSSL 1.0.2g  1 Mar 2016
Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX#] [ -B size ] [ -c count ]
        [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]
        [ -i interface ] [ -j tstamptype ] [ -M secret ] [ --number ]
        [ -Q in|out|inout ]
        [ -r file ] [ -s snaplen ] [ --time-stamp-precision precision ]
        [ --immediate-mode ] [ -T type ] [ --version ] [ -V file ]
        [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z command ]
        [ -Z user ] [ expression ]</code></pre><blockquote><p>What does dumpcap -v print? (The entire output, not just the dumpcap version number.)</p></blockquote><pre><code>Dumpcap (Wireshark) 2.0.2 (SVN Rev Unknown from unknown)

Copyright 1998-2016 Gerald Combs &lt;[email protected]&gt; and contributors.
License GPLv2+: GNU GPL version 2 or later &lt;http://www.gnu.org/licenses/old-licenses/gpl-2.0.html&gt;
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Compiled (64-bit) with GLib 2.48.0, with libpcap, with POSIX capabilities
(Linux), with libnl 3, with libz 1.2.8.

Running on Linux 4.4.0-43-generic, with locale C, with libpcap version 1.7.4,
with libz 1.2.8.
Intel(R) Core(TM)2 CPU          6600  @ 2.40GHz

Built using gcc 5.3.1 20160407.</code></pre><blockquote><p>What does ls -l <code>which tcpdump</code> print?</p></blockquote><pre><code>-rwxr-x--- 1 root pcap 1106360 Jun  2  2015 /usr/sbin/tcpdump</code></pre><blockquote><p>What does ls -l <code>which dumpcap</code> print?</p></blockquote><pre><code>-rwxr-xr-x 1 root root 88272 Apr  8  2016 /usr/bin/dumpcap</code></pre><p>Does this suggest that I still have an out of date version of tcpdump?</p></div><div id="comment-56353-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:21)</span> davehigton</div></div><span id="56357"></span><div id="comment-56357" class="comment not_top_scorer"><div id="post-56357-score" class="comment-score"></div><div class="comment-text"><blockquote><p>What does tcpdump -h print?</p></blockquote><pre><code>tcpdump version 4.7.4
libpcap version 1.7.4
OpenSSL 1.0.2g  1 Mar 2016
Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX#] [ -B size ] [ -c count ]
        [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]
        [ -i interface ] [ -j tstamptype ] [ -M secret ] [ --number ]
        [ -Q in|out|inout ]
        [ -r file ] [ -s snaplen ] [ --time-stamp-precision precision ]
        [ --immediate-mode ] [ -T type ] [ --version ] [ -V file ]
        [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z command ]
        [ -Z user ] [ expression ]</code></pre><p><code></code></p><code></code><p><code></code></p><p><code></code></p></div><div id="comment-56357-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:29)</span> davehigton</div></div><span id="56358"></span><div id="comment-56358" class="comment not_top_scorer"><div id="post-56358-score" class="comment-score"></div><div class="comment-text"><blockquote><p>What does dumpcap -v print?</p></blockquote><p><code>Dumpcap (Wireshark) 2.0.2 (SVN Rev Unknown from unknown)</code></p><p><code></code></p><p><code>Copyright 1998-2016 Gerald Combs [email protected] and contributors. License GPLv2+: GNU GPL version 2 or later http://www.gnu.org/licenses/old-licenses/gpl-2.0.html This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></p><code></code><p>Compiled (64-bit) with GLib 2.48.0, with libpcap, with POSIX capabilities (Linux), with libnl 3, with libz 1.2.8.</p><p>Running on Linux 4.4.0-43-generic, with locale C, with libpcap version 1.7.4, with libz 1.2.8. Intel(R) Core(TM)2 CPU 6600 @ 2.40GHz</p></code><p><code>Built using gcc 5.3.1 20160407.</code></p></div><div id="comment-56358-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:29)</span> davehigton</div></div><span id="56359"></span><div id="comment-56359" class="comment not_top_scorer"><div id="post-56359-score" class="comment-score"></div><div class="comment-text"><blockquote><p>What does ls -l <code>which tcpdump</code> print?</p></blockquote><p><code>-rwxr-x--- 1 root pcap 1106360 Jun  2  2015 /usr/sbin/tcpdump</code></p></div><div id="comment-56359-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:31)</span> davehigton</div></div><span id="56360"></span><div id="comment-56360" class="comment not_top_scorer"><div id="post-56360-score" class="comment-score"></div><div class="comment-text"><blockquote><p>What does ls -l <code>which dumpcap</code> print?</p></blockquote><p><code>-rwxr-xr-x 1 root root 88272 Apr  8  2016 /usr/bin/dumpcap</code></p></div><div id="comment-56360-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:32)</span> davehigton</div></div><span id="56361"></span><div id="comment-56361" class="comment not_top_scorer"><div id="post-56361-score" class="comment-score"></div><div class="comment-text"><p>Does this indicate that I still have an out of date version of tcpdump?</p></div><div id="comment-56361-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:34)</span> davehigton</div></div><span id="56362"></span><div id="comment-56362" class="comment not_top_scorer"><div id="post-56362-score" class="comment-score"></div><div class="comment-text"><blockquote><p>What you describe seems to be only the exchange related to LED control.</p></blockquote><p>Absolutely. The interrupt in message from the keyboard wasn't in question, so I didn't mention it. I believe that I'm seeing /all/ messages on the USB, including the control transfer to command the LED status, and a USB ACK (a level that we don't normally care about) to signal back from device to host that the control transfer succeeded.</p></div><div id="comment-56362-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:40)</span> davehigton</div></div><span id="56363"></span><div id="comment-56363" class="comment not_top_scorer"><div id="post-56363-score" class="comment-score"></div><div class="comment-text"><p>It indicates that you have a reasonably recent version of <em>libpcap</em>, and a reasonably recent version of tcpdump, which is using that version of libpcap, and that dumpcap is using the same version of libpcap.</p><p>It's libpcap that matters here.</p></div><div id="comment-56363-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:41)</span> Guy Harris ♦♦</div></div><span id="56364"></span><div id="comment-56364" class="comment not_top_scorer"><div id="post-56364-score" class="comment-score"></div><div class="comment-text"><blockquote><p>Does this suggest that I still have an out of date version of tcpdump?</p></blockquote><p>Your <code>tcpdump</code> is older than your <code>dumpcap</code> but it doesn't matter as <code>tcpdump</code> is not part of the Wireshark project, so unlike your Wireshark 1.12.x was, your <code>tcpdump</code> is not a zombie as reinstallation of Wireshark does not affect it.</p><p>What really bothers me is that, as now confirmed, both <code>tcpdump</code> and <code>dumpcap</code> use the same <code>libpcap</code> (1.7.4) and still give different results. As said, can you please capture the same usb activity into a file once using <code>tcpdump</code> and once using <code>dumpcap</code> with the same parameters (<code>-i usbmon -s 0 -w /some/file/name</code> and compare the results? Doing so should highlight whether the bug is between libpcap and the rest of dumpcap code or, less likely, between dumpcap and Wireshark during live capture.</p></div><div id="comment-56364-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:43)</span> sindy</div></div><span id="56365"></span><div id="comment-56365" class="comment not_top_scorer"><div id="post-56365-score" class="comment-score"></div><div class="comment-text"><blockquote><p>Does this indicate that I still have an out of date version of tcpdump?</p></blockquote><p>On second thoughts: no, according to www.tcpdump.org.</p></div><div id="comment-56365-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:43)</span> davehigton</div></div><span id="56366"></span><div id="comment-56366" class="comment not_top_scorer"><div id="post-56366-score" class="comment-score"></div><div class="comment-text"><p>So:</p><p>Does tcpdump truncate any USB packets when you capture a particular sequence of traffic, such as the "repeatedly hitting Num Lock" sequence?</p><p>Does a capture done with Wireshark do so for the same sequence of traffic?</p><p>Does a capture done with dumpcap on the command line do so for the same sequence of traffic?</p></div><div id="comment-56366-info" class="comment-info"><span class="comment-age">(13 Oct '16, 13:55)</span> Guy Harris ♦♦</div></div></div><div id="comment-tools-55846" class="comment-tools"><span class="comments-showing"> showing 5 of 24 </span> <a href="#" class="show-all-comments-link">show 19 more comments</a></div><div class="clear"></div><div id="comment-55846-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="56391"></span>

<div id="answer-container-56391" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-56391-score" class="post-score" title="current number of votes">0</div></div></td><td><div class="item-right"><div class="answer-body"><p>Wireshark on Linux can capture USB traffic without truncating it to 48 bytes, kernel 4.4 is new enough such that you do not have to worry about the historical limitation. Are you sure that your device is not sending less? While comparing libpcap versions is an option, to be absolutely sure you can first whether the kernel gives actually gives you data.</p><p>So, check whether the kernel (USB device) really returns more than 48 bytes. To do so, either access the device nodes in debugfs (<code>cat /sys/kernel/debug/usb/usbmon/*u</code>) or invoke ioctls on the <code>/dev/usbmon*</code> devices. (Here, <code>*</code> is the bus number or <code>0</code> for a catch-all.)</p><p>Pay especially attention to the number before the equals sign. This is the actual data length. For the textual output in debugfs, the data after <code>=</code> is truncated to 32 bytes (see <code>DATA_MAX</code> in the kernel sources, <code>drivers/usb/mon/mon_text.c</code>).</p><p>You can run the above experiment while capturing with <code>tcpdump -i usbmon*</code> (or Wireshark), the results should match up. If not, you could try to run <code>strace</code> against the capture process (tcpdump or dumpcap), but if this happens, then something is seriously wrong. Maybe you are capturing from the wrong usbmon device?</p><p>Related material:</p><ul><li><a href="https://www.kernel.org/doc/Documentation/usb/usbmon.txt">https://www.kernel.org/doc/Documentation/usb/usbmon.txt</a> (describes debugfs output and the ioctls).</li><li><a href="https://wiki.wireshark.org/CaptureSetup/USB#Linux">https://wiki.wireshark.org/CaptureSetup/USB#Linux</a></li></ul></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>14 Oct '16, 14:29</strong></p><img src="https://secure.gravatar.com/avatar/285b1f0f4caadc088a38c40aea22feba?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Lekensteyn&#39;s gravatar image" /><p>Lekensteyn<br />
<span class="score" title="2213 reputation points"><span>2.2k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="7 badges"><span class="silver">●</span><span class="badgecount">7</span></span><span title="24 badges"><span class="bronze">●</span><span class="badgecount">24</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Lekensteyn has 32 accepted answers">30%</span></p></div></div><div id="comments-container-56391" class="comments-container"></div><div id="comment-tools-56391" class="comment-tools"></div><div class="clear"></div><div id="comment-56391-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

