+++
type = "question"
title = "Ignoring the first X bytes of a packet"
description = '''Hello, community. I&#x27;m capturing packets where the first X bytes (a special header) are not covered by any dissector available. Therefore, the rest of the package is not dissected anymore. Is it possible to instruct Wireshark to ignore the first X bytes and proceed further? Or is the only feasible op...'''
date = "2012-10-29T07:27:00Z"
lastmod = "2012-10-31T01:59:00Z"
weight = 15337
keywords = [ "ignore", "bytes", "mask" ]
aliases = [ "/questions/15337" ]
osqa_answers = 2
osqa_accepted = true
+++

<div class="headNormal">

# [Ignoring the first X bytes of a packet](/questions/15337/ignoring-the-first-x-bytes-of-a-packet)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-15337-score" class="post-score" title="current number of votes">2</div><div id="favorite-count" class="favorite-count">1</div></div></td><td><div id="item-right"><div class="question-body"><p>Hello, community. I'm capturing packets where the first X bytes (a special header) are not covered by any dissector available. Therefore, the rest of the package is not dissected anymore. Is it possible to instruct Wireshark to ignore the first X bytes and proceed further? Or is the only feasible option to write an own dissector for the first part of the package - the first X bytes?</p><p>BR Ewgenij</p></div><div id="question-tags" class="tags-container tags">ignore bytes mask</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>29 Oct '12, 07:27</strong></p><img src="https://secure.gravatar.com/avatar/74ba4ba7a26d5efda01b6ae18bbe48e4?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Ewgenijkkg&#39;s gravatar image" /><p>Ewgenijkkg<br />
<span class="score" title="66 reputation points">66</span><span title="8 badges"><span class="badge1">●</span><span class="badgecount">8</span></span><span title="9 badges"><span class="silver">●</span><span class="badgecount">9</span></span><span title="15 badges"><span class="bronze">●</span><span class="badgecount">15</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Ewgenijkkg has 3 accepted answers">60%</span></p></div><div class="post-update-info post-update-info-edited"><p>edited 29 Oct '12, 15:05</p><img src="https://secure.gravatar.com/avatar/d2a7e24ca66604c749c7c88c1da8ff78?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="grahamb&#39;s gravatar image" /><p>grahamb ♦<br />
<span class="score" title="19834 reputation points"><span>19.8k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="30 badges"><span class="silver">●</span><span class="badgecount">30</span></span><span title="206 badges"><span class="bronze">●</span><span class="badgecount">206</span></span></p></div></div><div id="comments-container-15337" class="comments-container"><span id="15345"></span><div id="comment-15345" class="comment"><div id="post-15345-score" class="comment-score"></div><div class="comment-text"><p>Capturing with Wireshark (or tcpdump or some other libpcap/WinPcap-based tool), or with some other special software (possibly piping to Wireshark/TShark over a named pipe, or possibly capturing to a file and having Wireshark read the file)? If Wireshark's only reading the file, what format is it? If it's a pcap or pcap-ng file, or a live capture, what's the link-layer header type? Perhaps a new link-layer header type needs to be assigned to it.</p></div><div id="comment-15345-info" class="comment-info"><span class="comment-age">(29 Oct '12, 14:22)</span> Guy Harris ♦♦</div></div><span id="15349"></span><div id="comment-15349" class="comment"><div id="post-15349-score" class="comment-score"></div><div class="comment-text"><p>Hello. The capture was performed with tcpdump. Wireshark reads the dump file then.</p><blockquote><p>If Wireshark's only reading the file, what format is it?</p></blockquote><p>It was captured with the -w option of tcpdump, thus I suppose its the pcap-savefile format.</p><blockquote><p>what's the link-layer header type</p></blockquote><p>The packets were captured on a wireless interface. The wireless communication is running over special wirelss modules of Cohda <a href="http://www.cohdawireless.com/">http://www.cohdawireless.com/</a> The Cohda headers are unknown to Wireshark, therefore no processing is possible. Thus, the idea was to remove these additional bytes from the capture file.</p><p>Regards Ewgenij Sokolovski</p></div><div id="comment-15349-info" class="comment-info"><span class="comment-age">(30 Oct '12, 01:20)</span> Ewgenijkkg</div></div><span id="15360"></span><div id="comment-15360" class="comment"><div id="post-15360-score" class="comment-score"></div><div class="comment-text"><p>[I converted your comment from an Answer to a comment to keep things structured]</p><p>Can you provide a sample trace to take a look at? If that is not possible, how many bytes do you need to remove from the start of each packet?</p></div><div id="comment-15360-info" class="comment-info"><span class="comment-age">(30 Oct '12, 03:48)</span> Jasper ♦♦</div></div><span id="15369"></span><div id="comment-15369" class="comment"><div id="post-15369-score" class="comment-score"></div><div class="comment-text"><p>Hello, it's not a secret :) Here is the example</p><p>a1 b2 c3 d4 00 02 00 04 00 00 00 00 00 00 00 00 00 00 00 44 00 00 00 71 50 8a 5e 87 00 05 be e0 00 00 00 44 00 00 00 87 00 04 ff fe 00 06 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff 04 e5 48 01 d7 02 ff ff ff ff ff ff 00 00 00 00 aa aa 03 00 00 00 07 07</p><p>The last two bytes 07 07 are the protocal type and the 12 bytes before them are destination and source MAC addresses.</p></div><div id="comment-15369-info" class="comment-info"><span class="comment-age">(30 Oct '12, 08:38)</span> Ewgenijkkg</div></div><span id="15370"></span><div id="comment-15370" class="comment"><div id="post-15370-score" class="comment-score"></div><div class="comment-text"><p>The sequence</p><p>00 05 be e0 00 00 00 44 00 00 00 87 00 04 ff fe 00 06 00 00 00 00 00 00 00 00 00 00 ff ff ff ff ff ff 04 e5 48 01 d7 02 ff ff ff ff</p><p>is then the special Cohda stuff, which wireshark apparently can't deal with.</p><p>BR Ewgenij</p><p>P.S. Isn't it possible to place more signs in one single comment? I got to split the text in two comments :(</p></div><div id="comment-15370-info" class="comment-info"><span class="comment-age">(30 Oct '12, 08:40)</span> Ewgenijkkg</div></div><span id="15376"></span><div id="comment-15376" class="comment not_top_scorer"><div id="post-15376-score" class="comment-score"></div><div class="comment-text"><p>Yeah, the length limitation of comments is a constant problem... no idea if the admins could increase the limit.</p><p>Can you upload the sample to <a href="http://www.cloudshark.org">www.cloudshark.org</a> and post the link? That would make it easier to look at things in a binary way. If I get this correctly from what you've posted the Destination MAC is ff:ff:00:00:00:00, the Source MAC is aa:aa:03:00:00:00, and the ether type 0x0707. Correct?</p><p>What is the stuff that comes before the Cohda stuff, starting with a1 b2 c3 ... up to 50 8a 5e 87?</p></div><div id="comment-15376-info" class="comment-info"><span class="comment-age">(30 Oct '12, 09:33)</span> Jasper ♦♦</div></div><span id="15397"></span><div id="comment-15397" class="comment not_top_scorer"><div id="post-15397-score" class="comment-score"></div><div class="comment-text"><blockquote><p>The packets were captured on a wireless interface.</p></blockquote><p>Cohda offers a wireless board with a CAN bus and USB 2.0 host interface. So, how and where did you capture the data?</p><p>Is it an embedded linux running on the board itself or through a driver that offers some kind of (wireless) interface to a standard linux?</p></div><div id="comment-15397-info" class="comment-info"><span class="comment-age">(30 Oct '12, 13:29)</span> Kurt Knochner ♦</div></div></div><div id="comment-tools-15337" class="comment-tools"><span class="comments-showing"> showing 5 of 7 </span> <a href="#" class="show-all-comments-link">show 2 more comments</a></div><div class="clear"></div><div id="comment-15337-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

2 Answers:

</div>

</div>

<span id="15388"></span>

<div id="answer-container-15388" class="answer accepted-answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-15388-score" class="post-score" title="current number of votes">7</div></div></td><td><div class="item-right"><div class="answer-body"><p>Actually, no, the 12 bytes before 07 07 are <em>NOT</em> destination source and MAC addresses. aa aa 03 is an IEEE 802.2 header with a DSAP and SSAP of aa, meaning SNAP (at this point my brain's wired to recognize aa aa 03 :-)); the 00 00 00 07 07 is a SNAP header with an OUI of 00 00 00, meaning "the protocol ID is an Ethernet type", and a protocol ID of 07 07, which <a href="http://standards.ieee.org/cgi-bin/ethsearch?search_term=0707&amp;submit2=Search%21">is not a publicly registered Ethernet type</a> and not listed in <a href="http://standards.ieee.org/develop/regauth/ethertype/eth.txt">the official IEEE registry of Ethertypes</a> as of 2012-10-30. However, Googling for "ethertype 0707" found <a href="http://www.etsi.org/plugtests/ITS_CMS/Document/ITS_TestDescriptions%20v009.pdf">ETSI CTI Plugtests Guide Stable Draft V0.0.9 (2011-11) "Cooperative Mobility Services Plugtests; Helmond, Netherlands; 14 - 18 November 2011"</a>, which says "The ether type 0x0707 shall be used to indicate a GeoNetworking packet." It also says "The PHY layer of the communication system is based on IEEE802.11p-2010."</p><p>The ff ff ff ff ff ff 04 e5 48 01 d7 02 ff ff ff ff ff ff preceding it looks as if it might be <em>three</em> MAC addresses - two broadcast and one unicast.</p><p>Digging around looking for specifications for the protocols being used (and avoiding any references to ISO standards, as I'm a cheap bastard and would rather not pay, for example, CHF 140 or so for one of the standards I found) found <a href="http://www.etsi.org/deliver/etsi_en/302600_302699/302665/01.01.01_60/en_302665v010101p.pdf">ETSI EN 302 665 V1.1.1 (2010-09) "Intelligent Transport Systems (ITS); Communications Architecture"</a>. That appeared to suggest that one link layer for this was <a href="http://www.etsi.org/deliver/etsi_es/202600_202699/202663/01.01.00_50/es_202663v010100m.pdf">Final draft ETSI ES 202 663 V1.1.0 (2009-11) "Intelligent Transport Systems (ITS); European profile standard for the physical and medium access control layer of Intelligent Transport Systems operating in the 5 GHz frequency band"</a>, which is Good Old Wi-Fi. Another one to which it refers is ISO/IEC IS 21215 "Intelligent Transport Systems - Communications access for land mobiles (CALM) - M5 medium"; I'm too cheap (as noted earlier) to buy that document, but <a href="http://en.wikipedia.org/wiki/Communications,_Air-interface,_Long_and_Medium_range">the Wikipedia page for CALM</a> lists a bunch of link layers, including 802.11 (Wi-Fi), 802.16 (WiMAX), Bluetooth, and GSM/UMTS, and there's a link for "M5" that goes to <a href="http://en.wikipedia.org/wiki/CALM_M5">a Wikipedia page for CALM M5</a>, and that page says "CALM M5 is the ISO 21215 standard that incorporates WAVE (WAVE PHY/MAC is IEEE 802.11p standard) and adds the following features:..." So there might be an 802.11 header somewhere in there - or it might be WiMAX, or it might be something else. My guess is that it's <em>probably</em> either 802.11 or 802.16, given the 802.2+SNAP header.</p><p>So, looking at the hex dump:</p><blockquote><p>a1 b2 c3 d4</p></blockquote><p>OK, that's a pcap file magic number, so I'm guessing this is a dump of the full pcap file. That means that:</p><blockquote><p>00 02</p></blockquote><p>Major pcap file format version number 2</p><blockquote><p>00 04</p></blockquote><p>Minor pcap file format version number 4</p><blockquote><p>00 00 00 00</p></blockquote><p>Time zone offset (which nobody ever actually sets, so it's always zero in practice)</p><blockquote><p>00 00 00 00</p></blockquote><p>Time stamp accuracy (which nobody ever actually sets, so it's always zero in practice)</p><blockquote><p>00 00 00 44</p></blockquote><p>Snapshot length (68, which was, until recently, the tcpdump default for non-IPv6-enabled tcpdump; the default is now 65535 so you get full packets by default)</p><blockquote><p>00 00 00 71</p></blockquote><p>Link-layer header type (113, which is <code>LINKTYPE_LINUX_SLL</code>, used on Linux for the "any" device, some interfaces known to supply bogus headers such as PPP interfaces, <em>and</em> interfaces for which the <code>ARPHRD_</code> value returned by the OS isn't one libpcap knows about; this is probably tcpdump on Linux with an unknown <code>ARPHRD_</code> value)</p><blockquote><p>50 8a 5e 87</p></blockquote><p>Time stamp, seconds part</p><blockquote><p>00 05 be e0</p></blockquote><p>TIme stamp, microseconds part</p><blockquote><p>00 00 00 44</p></blockquote><p>Captured data length (68 bytes)</p><blockquote><p>00 00 00 87</p></blockquote><p>Actual packet length on the network (135 bytes, so the packet data was cut short to 68 bytes)</p><p>And the packet data, with a <code>LINKTYPE_LINUX_SLL</code>/<code>DLT_LINUX_SLL</code> header, which is described on <a href="http://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL.html">the page linked to from the entry in the</a> <a href="http://tcpdump.org">tcpdump.org</a> link-layer header types page, is:</p><blockquote><p>00 04</p></blockquote><p>Packet type - "sent by us"</p><blockquote><p>ff fe</p></blockquote><p><code>ARPHRD_</code> type (<code>ARPHRD_NONE</code>, which claims to be "zero header length" in the comment for the entry in Linux's <code>if_arp.h</code>; is this going through a tuntap device from some user-land capture program?)</p><blockquote><p>00 06</p></blockquote><p>Link-layer address length - 6 octets (not surprising, if this is really 802.11 or even 802.16)</p><blockquote><p>00 00 00 00 00 00 00 00</p></blockquote><p>Link-layer address (as noted in the document, padded to 8 bytes)</p><blockquote><p>00 00</p></blockquote><p>Protocol type - 0x0000 is <em>NOT</em> a value listed in the Linux 3.0.4 <code>if_ether.h</code>, so that's either bogus, an undocumented value, or something in a later kernel version</p><blockquote><p>ff ff ff ff ff ff 04 e5 48 01 d7 02 ff ff ff ff ff ff 00 00 00 00</p></blockquote><p>A bunch of stuff that looks like MAC addresses plus 00 00 00 00</p><blockquote><p>aa aa 03 00 00 00 07 07</p></blockquote><p>802.2 and SNAP header</p><p>So Wireshark should be dissecting this as "Linux cooked-mode capture", and should be showing the payload as raw data, given that 0x0000 is not a known <code>ETH_P_</code> value in Linux.</p><p>So either Wireshark needs to be made to handle 0x0000 in that case, whatever the right thing to do there is, or the code in Linux (network layer or driver) or whatever's supplying the packets to the system needs to be fixed to set the protocol type correctly.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>30 Oct '12, 11:51</strong></p><img src="https://secure.gravatar.com/avatar/f93de7000747ab5efb5acd3034b2ebd7?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Guy%20Harris&#39;s gravatar image" /><p>Guy Harris ♦♦<br />
<span class="score" title="17443 reputation points"><span>17.4k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="35 badges"><span class="silver">●</span><span class="badgecount">35</span></span><span title="196 badges"><span class="bronze">●</span><span class="badgecount">196</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Guy Harris has 216 accepted answers">19%</span></p></div><div class="post-update-info post-update-info-edited"><p>edited 30 Oct '12, 12:29</p></div></div><div id="comments-container-15388" class="comments-container"><span id="15390"></span><div id="comment-15390" class="comment"><div id="post-15390-score" class="comment-score">1</div><div class="comment-text"><p>"at this point my brain's wired to recognize aa aa 03 :-)"... You Sir are scary... :-D</p></div><div id="comment-15390-info" class="comment-info"><span class="comment-age">(30 Oct '12, 11:54)</span> Jasper ♦♦</div></div><span id="15393"></span><div id="comment-15393" class="comment"><div id="post-15393-score" class="comment-score">1</div><div class="comment-text"><blockquote><p>"at this point my brain's wired to recognize aa aa 03 :-)"... You Sir are scary... :-D</p></blockquote><p>That's what <a href="https://www.ohloh.net/accounts/gharris">14 years of hacking Wireshark and 12 years of hacking libpcap/tcpdump</a> will do to your brain....</p></div><div id="comment-15393-info" class="comment-info"><span class="comment-age">(30 Oct '12, 12:25)</span> Guy Harris ♦♦</div></div><span id="15398"></span><div id="comment-15398" class="comment"><div id="post-15398-score" class="comment-score">1</div><div class="comment-text"><p>And if the Cohda device is a <a href="http://cohdawireless.com/product/mk2.html">MK2 WAVE-DSRC Radio</a>, then it's <em>definitely</em> 802.11p. If tcpdump was running on the embedded processor - the pcap file is big-endian, which makes it more likely that it was, as a typical Linux box is x86 and thus little-endian - you might want to ask the fine folks at Cohda Wireless to fix their driver, or whatever, to use <code>ARPHRD_IEEE80211</code> or <code>ARPHRD_IEEE80211_RADIOTAP</code> as the <code>ARPHRD_</code> type, and to supply the appropriate link-layer headers (802.11 or 802.11+radiotap).</p></div><div id="comment-15398-info" class="comment-info"><span class="comment-age">(30 Oct '12, 15:02)</span> Guy Harris ♦♦</div></div><span id="15485"></span><div id="comment-15485" class="comment"><div id="post-15485-score" class="comment-score"></div><div class="comment-text"><p>OK, guys, thank you very much for your in-depth answers. I will investigate then :)</p><p>Greetings from Germany Ewgenij</p></div><div id="comment-15485-info" class="comment-info"><span class="comment-age">(02 Nov '12, 02:07)</span> Ewgenijkkg</div></div><span id="15486"></span><div id="comment-15486" class="comment"><div id="post-15486-score" class="comment-score"></div><div class="comment-text"><blockquote><p>So Wireshark should be dissecting this as "Linux cooked-mode capture", and should be showing the payload as raw data, given that 0x0000 is not a known ETH_P_ value in Linux.</p></blockquote><p>So, if 0x0000 would be a valid protocol value, the header would not be linux-cooked capture but ethernet, for example. Do I understand it right? And independent from that, if bytes after the link-layer would fit into higher level protocols, Wireshark would dissect them correctly? It would not present them as raw bytes, if I got it right. Did I? :)</p></div><div id="comment-15486-info" class="comment-info"><span class="comment-age">(02 Nov '12, 02:39)</span> Ewgenijkkg</div></div></div><div id="comment-tools-15388" class="comment-tools"></div><div class="clear"></div><div id="comment-15388-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<span id="15408"></span>

<div id="answer-container-15408" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-15408-score" class="post-score" title="current number of votes">0</div></div></td><td><div class="item-right"><div class="answer-body"><p>Hi Ewgenij,</p><p>I strongly suggest you get in contact with the folks at Cohda: <a href="http://www.cohdawireless.com/contact/default.html">http://www.cohdawireless.com/contact/default.html</a></p><p>They provide both a wireshark plugin to dissect their proprietary headers and a mechanism to switch the monitoring interface to ARPHRD_IEEE80211.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>31 Oct '12, 01:59</strong></p><img src="https://secure.gravatar.com/avatar/048a93a04e3d7ca7be6dfa1828b369a4?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Jason%20Boyd&#39;s gravatar image" /><p>Jason Boyd<br />
<span class="score" title="1 reputation points">1</span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Jason Boyd has no accepted answers">0%</span></p></div></div><div id="comments-container-15408" class="comments-container"><span id="15411"></span><div id="comment-15411" class="comment"><div id="post-15411-score" class="comment-score"></div><div class="comment-text"><p>If they provide that dissector to their commercial customers, I think they have to disclose the source code of the dissector, due to GPL licensing ;-)</p></div><div id="comment-15411-info" class="comment-info"><span class="comment-age">(31 Oct '12, 02:39)</span> Kurt Knochner ♦</div></div><span id="15425"></span><div id="comment-15425" class="comment"><div id="post-15425-score" class="comment-score"></div><div class="comment-text"><p>And if their documentation doesn't explain that you want to switch the monitoring interface to <code>ARPHRD_IEEE80211</code>, they need to fix it. For that matter, unless there's some compelling reason why either <code>ARPHRD_IEEE80211</code> or <code>ARPHRD_IEEE80211_RADIOTAP</code> shouldn't be the <em>only</em> mode, they should make it so - maybe <code>ARPHRD_ETHER</code> should be an alternative, and possibly the default alternative, but <code>ARPHRD_NONE</code> is completely bogus. (If they make it a <a href="http://www.linuxwireless.org">mac80211 driver</a>, perhaps that'll handle all that for them.)</p></div><div id="comment-15425-info" class="comment-info"><span class="comment-age">(31 Oct '12, 09:59)</span> Guy Harris ♦♦</div></div><span id="15488"></span><div id="comment-15488" class="comment"><div id="post-15488-score" class="comment-score"></div><div class="comment-text"><blockquote><p>They provide both a wireshark plugin to dissect their proprietary headers</p></blockquote><p>Are you sure? I could not find anything about the plugin on their website...</p></div><div id="comment-15488-info" class="comment-info"><span class="comment-age">(02 Nov '12, 03:19)</span> Ewgenijkkg</div></div></div><div id="comment-tools-15408" class="comment-tools"></div><div class="clear"></div><div id="comment-15408-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

