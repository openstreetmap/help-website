+++
type = "question"
title = "Intermittent SSL Decryption"
description = '''I am experiencing intermittent SSL decryption failures (10% success 90% failure) using Wireshark in accordance with the decryption protocol described here:  https://isc.sans.edu/forums/diary/Psst+Your+Browser+Knows+All+Your+Secrets/16415/ After very many attempts I have, I believe, narrowed the prob...'''
date = "2017-04-22T09:47:00Z"
lastmod = "2017-04-26T02:54:00Z"
weight = 60970
keywords = [ "ssl", "decryption", "intermittent" ]
aliases = [ "/questions/60970" ]
osqa_answers = 1
osqa_accepted = false
+++

<div class="headNormal">

# [Intermittent SSL Decryption](/questions/60970/intermittent-ssl-decryption)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-60970-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-60970-score" class="post-score" title="current number of votes">0</div><span id="post-60970-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span> <span id="favorite-mark" class="ajax-command favorite-mark" rel="nofollow" title="mark/unmark this question as favorite (click again to cancel)"> </span><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>I am experiencing intermittent SSL decryption failures (10% success 90% failure) using Wireshark in accordance with the decryption protocol described here:<br />
</p><p><a href="https://isc.sans.edu/forums/diary/Psst+Your+Browser+Knows+All+Your+Secrets/16415/">https://isc.sans.edu/forums/diary/Psst+Your+Browser+Knows+All+Your+Secrets/16415/</a></p><p>After very many attempts I have, I believe, narrowed the problem down to the following hypothesis: My browser (Firefox, Version 45.7.0) writes down several SSL keys in the SSLKey.log text file, many of which are unrelated to the TCP/TLSv1.2 stream of interest. It would appear that Wireshark is selecting the incorrect SSL key from the SSLkey.log file to decode the traffic of interest, and thus the decryption fails.</p><p>So, here are some intermediate questions to help me arrive at a final solution: (1) How does Wireshark select the SSl session key (from SSLkey.log) that it uses to decrypt a stream, which the user has selected for decryption ? (2) Is there a way to force Wireshark to cycle through and to use ALL the stored keys in SSLkey.log in succession, in order to decrypt the user selected stream ? (3) Is there a better method which will unfailing force Wireshark to correctly select the right SSL session key from the SSLkey.log file for its decryption attempt?</p><p>For analysing this problem, I am using Wireshark to decrypt the source of the video feed in the following site:</p><p><a href="http://www.airclips.net/video/airbus-a400m-atlas-german-air-force-54-04-go-around-at-landsberg-airbase">http://www.airclips.net/video/airbus-a400m-atlas-german-air-force-54-04-go-around-at-landsberg-airbase</a></p><p>Finally, In searching the Wireshark.org database for previously reported problems in this connection, the only entry which I found, is the following, as yet unanswered, question:</p><p><a href="https://ask.wireshark.org/questions/46368/ssl-decryption-seems-intermittent">https://ask.wireshark.org/questions/46368/ssl-decryption-seems-intermittent</a></p></div><div id="question-tags" class="tags-container tags"><span class="post-tag tag-link-ssl" rel="tag" title="see questions tagged &#39;ssl&#39;">ssl</span> <span class="post-tag tag-link-decryption" rel="tag" title="see questions tagged &#39;decryption&#39;">decryption</span> <span class="post-tag tag-link-intermittent" rel="tag" title="see questions tagged &#39;intermittent&#39;">intermittent</span></div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>22 Apr '17, 09:47</strong></p><img src="https://secure.gravatar.com/avatar/469e7fba59f37c655afa16ea559bee97?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Utnapishtim&#39;s gravatar image" /><p><span>Utnapishtim</span><br />
<span class="score" title="31 reputation points">31</span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="3 badges"><span class="silver">●</span><span class="badgecount">3</span></span><span title="6 badges"><span class="bronze">●</span><span class="badgecount">6</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Utnapishtim has one accepted answer">100%</span> </br></p></div></div><div id="comments-container-60970" class="comments-container"></div><div id="comment-tools-60970" class="comment-tools"></div><div class="clear"></div><div id="comment-60970-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="60985"></span>

<div id="answer-container-60985" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-60985-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-60985-score" class="post-score" title="current number of votes">0</div><span id="post-60985-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span></div></td><td><div class="item-right"><div class="answer-body"><p>Your hypothesis</p><blockquote><p>It would appear that Wireshark is selecting the incorrect SSL key from the SSLkey.log file to decode the traffic of interest, and thus the decryption fails.</p></blockquote><p>is invalid. Wireshark selects the secret based on the Random field in the Client Hello message. This process is deterministic, the same secret is selected each time (but only if it is present).</p><p>More likely scenarios:</p><ul><li>Firefox is too slow in writing the keylog file <em>or</em> Wireshark reads the packets before the key appears in the key log file. In this case, saving the packet capture and then reloading the file should work. Alternatively, you can try toggling a preference which hopefully results in a redissection (and thus re-reading the packet capture).</li><li>Out-of-order TCP segments are received and the decryption state is confused. (See <a href="https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=9461).">https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=9461).</a> There is no solution for this at the moment other than using a tool to re-order TCP packets in a packet capture (I don't know any).</li></ul><p>Given that you are analyzing a video stream, out-of-order TCP segments sounds more likely to me.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>23 Apr '17, 05:35</strong></p><img src="https://secure.gravatar.com/avatar/285b1f0f4caadc088a38c40aea22feba?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Lekensteyn&#39;s gravatar image" /><p><span>Lekensteyn</span><br />
<span class="score" title="2213 reputation points"><span>2.2k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="7 badges"><span class="silver">●</span><span class="badgecount">7</span></span><span title="24 badges"><span class="bronze">●</span><span class="badgecount">24</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Lekensteyn has 32 accepted answers">30%</span></p></div></div><div id="comments-container-60985" class="comments-container"><span id="60993"></span><div id="comment-60993" class="comment"><div id="post-60993-score" class="comment-score"></div><div class="comment-text"><p>Thank you for your helpful reply.</p><p>I tried Scenario 1 (saving the packet capture, then reloading it). It failed to correctly decrypt the video stream. This only leaves Scenario 2 and reinforces your comment <em>"Given that you are analyzing a video stream, out-of-order TCP segments sounds more likely to me."</em></p><p>This result brings me back to sub-question (2) of my original question, namely: <em>Is there a way to force Wireshark to cycle through and to use ALL the stored keys in SSLkey.log in succession, in order to decrypt the user selected stream ?</em></p><p>Doing this would unfailingly solve the decryption problem under both of your scenarios. If this exhaustive search is not possible in the 'standard' Wireshark, would it be difficult to tweak the source code to accomplish it?</p></div><div id="comment-60993-info" class="comment-info"><span class="comment-age">(23 Apr '17, 12:34)</span> <span class="comment-user userinfo">Utnapishtim</span></div></div><span id="61020"></span><div id="comment-61020" class="comment"><div id="post-61020-score" class="comment-score"></div><div class="comment-text"><p>TLS does not work like that, you cannot just "decrypt" each packet with the same key. At the beginning of a handshake, a key is agreed on, but decryption of further records depends on earlier ones. If the order is wrong, then the correct decryption keys for the following records cannot be derived. Brute-forcing through an exhaustive search would now work.</p><p>What would work is fixing up the TCP dissector to put the TCP segments in the correct order, but this is still an open issue (see the bug I linked in the post).</p></div><div id="comment-61020-info" class="comment-info"><span class="comment-age">(24 Apr '17, 13:45)</span> <span class="comment-user userinfo">Lekensteyn</span></div></div><span id="61053"></span><div id="comment-61053" class="comment"><div id="post-61053-score" class="comment-score"></div><div class="comment-text"><p>Once again, thank you for your helpful reply. Please excuse the delay in my response. I am unfamiliar with SSL/TLS and had to spend time reading up on them.</p><p>Also, kindly bear with me but I am having difficulty following your statement that: <em>" the correct decryption keys for the following records cannot be derived"</em></p><p>To speedily allow you to point out the error(s) in my understanding, I have enumerated below, the events which I believe are occurring during the TLS session key generation process. This understanding is based on my reading of references [1, 2, 3]. I have not been able to determine exactly what my browser is recording in the SSLkey.log text file (step 7 below). The best information which I have managed to obtain is given in reference [4]. Accordingly, there are two possibilities (a) only the session keys themselves are recorded (b) the session keys as well as the intermediate values ie client's random value, server's random value, client's premaster secret and server's premaster secret, are being recorded. Here are the steps per my understanding:</p><pre><code>1)  My Firefox Browser (the client), sends a &quot;Client hello&quot; message to the server hosting the website containing video (the URL of which I wish to know), along with the client&#39;s random value and supported cipher suites.
2)  The server responds by sending a &quot;Server hello&quot; message to the client, along with the server&#39;s random value.
3)  The server sends its certificate to the client for authentication and may request a certificate from the client. The server sends the &quot;Server hello done&quot; message.
4)  If the server has requested a certificate from the client, the client sends it.
5)  The client creates a random Pre-Master Secret and encrypts it with the public key from the server&#39;s certificate, sending the encrypted Pre-Master Secret to the server.
6)  The server receives the Pre-Master Secret. The server and client each generate the Master Secret and session keys based on the Pre-Master Secret.
7)  The client records the new session keys, one for hashing and a second for encrypting messages and perhaps intermediate values, in the SSLkey.log text file.
8)  The client sends &quot;Change cipher spec&quot; notification to server to indicate that the client will start using the new session keys for hashing and encrypting messages. Client also sends &quot;Client finished&quot; message.
9)  Server receives &quot;Change cipher spec&quot; and switches its record layer security state to symmetric encryption using the session keys. Server sends &quot;Server finished&quot; message to the client.
10) Client and server can now exchange application data over the secured channel they have established. All messages sent from client to server and from server to client are encrypted using session key.
11) It is possible that the website is &#39;nested&#39; ie transfers the client to one or more subsequent websites which all require steps 1-10 to be completed.</code></pre><p>Now, these SSLkey.log entries are being recorded by the Browser, which <strong>always</strong> correctly decrypts the stream of interest (video feed in my case), ie its unaffected by the incorrect byte order issue which is confusing Wireshark. Hence these entries are entirely correct. Also, regardless of the two possibilities which I mentioned for the contents of SSLkey.log, one of the entries must be the correct session key for decrypting the video stream. Moreover, per the TLS protocol described in steps 1 to 11, the session key for decryption remains unchanged throughout the decryption process ie shuffling the videofeed byte order would simply mess up the video but would not affect the decryption session key.<br />
</p><p>If the aforementioned is true, then using each of the entries of the SSLkey.log file in succession (exhaustive search), will unfailingly result in successfully decrypting the stream of interest, regardless of shuffles in byte order.</p><p>References [1] <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa380513(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/aa380513(v=vs.85).aspx</a> [2] <a href="https://uk.sans.org/reading-room/whitepapers/protocols/ssl-tls-beginners-guide-1029">https://uk.sans.org/reading-room/whitepapers/protocols/ssl-tls-beginners-guide-1029</a> [3] <a href="https://tlswg.github.io/tls13-spec/">https://tlswg.github.io/tls13-spec/</a> [4] <a href="https://enterprise.cloudshark.org/blog/2015-05-14-all-about-ssl-key-logging/">https://enterprise.cloudshark.org/blog/2015-05-14-all-about-ssl-key-logging/</a></p></div><div id="comment-61053-info" class="comment-info"><span class="comment-age">(25 Apr '17, 16:51)</span> <span class="comment-user userinfo">Utnapishtim</span></div></div><span id="61056"></span><div id="comment-61056" class="comment"><div id="post-61056-score" class="comment-score"></div><div class="comment-text"><blockquote>Now, these SSLkey.log entries are being recorded by the Browser, which always correctly decrypts the stream of interest (video feed in my case), ie its unaffected by the incorrect byte order issue which is confusing Wireshark.</blockquote><p>The browser won't see an out of order TCP packet, the host OS will present the TCP stream in order to the application.</p></div><div id="comment-61056-info" class="comment-info"><span class="comment-age">(26 Apr '17, 02:41)</span> <span class="comment-user userinfo">grahamb ♦</span></div></div><span id="61057"></span><div id="comment-61057" class="comment"><div id="post-61057-score" class="comment-score">1</div><div class="comment-text"><p>There are some inaccuracies in your assumptions (e.g. the Client Hello does not store the full URL for example, only the hostname), but let's disregard them and focus on the key material. Your step 7 is about the derivation of MAC (integrity), key/IV (symmetric encryption) as can be found in <a href="https://tools.ietf.org/html/rfc5246#section-6.3">RFC 5246 - TLS 1.2, Section 6.3. Key Calculation</a>. This key is derived from the Master Secret (which is derived from the pre-master secret) combined with the Client and Server Random values.</p><p>The key used in step 10 (for Application Data) is based on the key/IV as can be seen in the subsections after <a href="https://tools.ietf.org/html/rfc5246#section-6.2.3">Section 6.2.3. Record Payload Protection</a>. The integrity key depends on a sequence number. Out-of-order packets will result in the wrong integrity check and as a result decryption will fail.</p><p>The SSL keylog file stores a mapping from the Client Random value to the Master Secret. Thus it should become clear now that enumerating all entries in the SSL keylog file will not help since the Client Random value is unique and we can figure out whether the key exists or not.</p><p>Why does it work for the web browser and not Wireshark? The web browser relies on the operating system to buffer TCP segments and re-order to ensure a stream of data that fixes out-of-order packets. Wireshark (at least for SSL/TLS) currently does not do this re-ordering yet (see the linked bug) and will thus fail to provide the required ordering that is necessary for TLS decryption to function.</p></div><div id="comment-61057-info" class="comment-info"><span class="comment-age">(26 Apr '17, 02:54)</span> <span class="comment-user userinfo">Lekensteyn</span></div></div></div><div id="comment-tools-60985" class="comment-tools"></div><div class="clear"></div><div id="comment-60985-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

