+++
type = "question"
title = "Does reassembly address multiple PDUs in a single TCP segment?"
description = '''I&#x27;m starting to dig into the details of some capture files and have been humbled by the gaps in my knowledge that have been exposed in this process. I am using a Lua dissector for a protocol (call it MYPROTO) that is conveyed via TCP. I was puzzled by some extremely large TCP segments in the capture...'''
date = "2014-03-07T04:35:00Z"
lastmod = "2014-03-07T05:10:00Z"
weight = 30529
keywords = [ "lua", "dissector", "reassembly" ]
aliases = [ "/questions/30529" ]
osqa_answers = 0
osqa_accepted = true
+++

<div class="headNormal">

# [Does reassembly address multiple PDUs in a single TCP segment?](/questions/30529/does-reassembly-address-multiple-pdus-in-a-single-tcp-segment)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-30529-score" class="post-score" title="current number of votes">1</div><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>I'm starting to dig into the details of some capture files and have been humbled by the gaps in my knowledge that have been exposed in this process. I am using a Lua dissector for a protocol (call it MYPROTO) that is conveyed via TCP. I was puzzled by some extremely large TCP segments in the capture, but now understand that multiple MYPROTO PDUs can be carried in a single TCP segment. However, the Lua dissector only shows one MYPROTO PDU. (I'm still puzzled by the underlying question of why some segments are extremely large while others are not, but I can put that aside while I look to solve the dissector problem.)</p><p>I have been reading about reassembly, which I understand to mean the process of reassembling higher-level PDUs that may cross multiple TCP segments. If I modify the dissector to support reassembly, will the same mechanism allow the dissector to discover multiple MYPROTO PDUs within a single TCP segment?</p></div><div id="question-tags" class="tags-container tags">lua dissector reassembly</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>07 Mar '14, 04:35</strong></p><img src="https://secure.gravatar.com/avatar/143ca820606b9b8df4a6441003ef1b53?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="yotommy&#39;s gravatar image" /><p>yotommy<br />
<span class="score" title="36 reputation points">36</span><span title="2 badges"><span class="badge1">●</span><span class="badgecount">2</span></span><span title="2 badges"><span class="silver">●</span><span class="badgecount">2</span></span><span title="7 badges"><span class="bronze">●</span><span class="badgecount">7</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="yotommy has no accepted answers">0%</span></p></div><div class="post-update-info post-update-info-edited"><p>edited 07 Mar '14, 04:43</p></div></div><div id="comments-container-30529" class="comments-container"></div><div id="comment-tools-30529" class="comment-tools"></div><div class="clear"></div><div id="comment-30529-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="30531"></span>

<div id="answer-container-30531" class="answer accepted-answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-30531-score" class="post-score" title="current number of votes">3</div></div></td><td><div class="item-right"><div class="answer-body"><p>Not the last time I checked. I believe you have to write your dissector function with a loop internally, to handle the case of there being multiple of your protocol messages inside a single TCP segment. I could be wrong, but I don't believe wireshark will call your dissector function multiple times for the same TCP segment (or at least it didn't use to, though that may have changed). That should be easy enough for you to test though, and report back here with an answer. :)</p><p>Regardless, if your dissector doesn't use one of the two reassembly mechanisms/models, then wireshark has no idea how much of a segment(s) your protocol message consumed, since there's no inherent message framing inside TCP. So you at least have to use one of the reassembly models to handle the fact any given protocol message may cross one or more segment(s).</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>07 Mar '14, 05:10</strong></p><img src="https://secure.gravatar.com/avatar/d02f20c18a7742ec73a666f1974bf6dc?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Hadriel&#39;s gravatar image" /><p>Hadriel<br />
<span class="score" title="2652 reputation points"><span>2.7k</span></span><span title="2 badges"><span class="badge1">●</span><span class="badgecount">2</span></span><span title="9 badges"><span class="silver">●</span><span class="badgecount">9</span></span><span title="39 badges"><span class="bronze">●</span><span class="badgecount">39</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Hadriel has 30 accepted answers">18%</span></p></div></div><div id="comments-container-30531" class="comments-container"><span id="30532"></span><div id="comment-30532" class="comment"><div id="post-30532-score" class="comment-score">1</div><div class="comment-text"><p>For a C based "new" style dissector that returns the number of bytes it dissected, multiple PDU's per TCP segments are dissected. See the reassembly chapter in README.dissector.</p><p>I don't know if a Lua dissector can do this.</p></div><div id="comment-30532-info" class="comment-info"><span class="comment-age">(07 Mar '14, 05:31)</span> grahamb ♦</div></div><span id="30533"></span><div id="comment-30533" class="comment"><div id="post-30533-score" class="comment-score">1</div><div class="comment-text"><p>Yeah I was just about to correct myself, because it looks like there's a loop inside dissect_tcp() now. So it should work for Lua as well, if you use the new style of returning the number of bytes consumed. (or at least the Lua binding code does look for a number return value and passes that back in to wireshark, so the plumbing's there)</p></div><div id="comment-30533-info" class="comment-info"><span class="comment-age">(07 Mar '14, 05:44)</span> Hadriel</div></div><span id="30534"></span><div id="comment-30534" class="comment"><div id="post-30534-score" class="comment-score">1</div><div class="comment-text"><p>Large TCP sgements may be due to offloading, you can try to turn that off.</p></div><div id="comment-30534-info" class="comment-info"><span class="comment-age">(07 Mar '14, 05:54)</span> Anders ♦</div></div><span id="30536"></span><div id="comment-30536" class="comment"><div id="post-30536-score" class="comment-score"></div><div class="comment-text"><p>This is great info, thanks. I will modify the dissector to return the number of bytes consumed. Using this mechanism, will the buffer passed into the dissector always point to the beginning of the to-be-dissected data, or do I need to check pinfo.desegment_offset?</p></div><div id="comment-30536-info" class="comment-info"><span class="comment-age">(07 Mar '14, 06:01)</span> yotommy</div></div><span id="30568"></span><div id="comment-30568" class="comment"><div id="post-30568-score" class="comment-score"></div><div class="comment-text"><p>Modifying the Lua dissector to have it return the number of bytes consumed did not have an effect. So I created a loop inside the dissector to add a subtree when I have enough data and to request reassembly otherwise. This is working better, but the packet length shown in the display is that of the enclosing TCP segment rather than that of the MYPROTO PDU. Any tips for this?</p></div><div id="comment-30568-info" class="comment-info"><span class="comment-age">(07 Mar '14, 09:53)</span> yotommy</div></div><span id="30572"></span><div id="comment-30572" class="comment not_top_scorer"><div id="post-30572-score" class="comment-score"></div><div class="comment-text"><p>Can you post your code, or at least th relevant portions of it that weren't working with the number return model?</p></div><div id="comment-30572-info" class="comment-info"><span class="comment-age">(07 Mar '14, 10:28)</span> Hadriel</div></div><span id="30577"></span><div id="comment-30577" class="comment not_top_scorer"><div id="post-30577-score" class="comment-score"></div><div class="comment-text"><p>To demonstrate this, I modified the 'trivial' dissector provided on wireshark.org. The revised code is shown here: <a href="https://gist.github.com/yotommy/9418831">https://gist.github.com/yotommy/9418831</a> - sample capture file here: <a href="http://www.cloudshark.org/captures/ef2f1bb3e67a">http://www.cloudshark.org/captures/ef2f1bb3e67a</a></p></div><div id="comment-30577-info" class="comment-info"><span class="comment-age">(07 Mar '14, 12:04)</span> yotommy</div></div><span id="30579"></span><div id="comment-30579" class="comment not_top_scorer"><div id="post-30579-score" class="comment-score"></div><div class="comment-text"><p>Excellent - thanks for uploading that. I just tried your script and was worried something else was broken because I kept getting a Lua error in the second packet's dissection pane, and putting a print statement showed wireshark was only giving your dissector a 2-byte tvb/buffer.</p><p>But then I looked at the second packet closely and saw the IP header length field is wrong, indicating it really does think the payload is 2 bytes long - you must have created this packet by hand, right? :)</p><p>Anyway, I'll go investigate why the first packet isn't getting chopped up.</p></div><div id="comment-30579-info" class="comment-info"><span class="comment-age">(07 Mar '14, 13:15)</span> Hadriel</div></div><span id="30580"></span><div id="comment-30580" class="comment not_top_scorer"><div id="post-30580-score" class="comment-score"></div><div class="comment-text"><p>Yes, created the pcap file with text2pcap. There are two bytes left over in the first packet that ideally will be combined with the two bytes from the second packet to make another 'trivial' PDU. Thanks for your help.</p></div><div id="comment-30580-info" class="comment-info"><span class="comment-age">(07 Mar '14, 13:31)</span> yotommy</div></div><span id="30581"></span><div id="comment-30581" class="comment not_top_scorer"><div id="post-30581-score" class="comment-score"></div><div class="comment-text"><p>Hmm... not only does it not work in 1.11, 1,10, nor 1.8, but I don't see how it <em>ever</em> worked. The loop I saw is in tcp_dissect_pdus(), and it's not exposed for Lua scripts to use, but it has to be used.<br />
</p><p>So returning a number is meaningless, even though the Lua binding C-code registers the dissector as a new type and passes back the number. The TCP dissector must have worked differently a long time ago, or else this behavior was never tested.</p><p>Looks like you'll have to write your own looping code in Lua, before returning from the dissector() function.</p><p>I'll submit a bug to track this, though I'll have to think about the best way to enable this to work. It's always a tricky balance of exposing too much of the internals and potentially breaking scripts if the internals change in the future, vs. exposing too little and making it not powerful enough and making the Lua script writer have to do more work.</p></div><div id="comment-30581-info" class="comment-info"><span class="comment-age">(07 Mar '14, 14:17)</span> Hadriel</div></div><span id="30582"></span><div id="comment-30582" class="comment not_top_scorer"><div id="post-30582-score" class="comment-score"></div><div class="comment-text"><p>Thanks for taking a careful look. One last (?) question: I've experimented with some looping code that adds multiple MYPROTO subtrees. Is there anyway to get Wireshark to display one row per MYPROTO PDU rather than having multiple PDUs grafted to a single TCP row?</p></div><div id="comment-30582-info" class="comment-info"><span class="comment-age">(07 Mar '14, 14:22)</span> yotommy</div></div><span id="30584"></span><div id="comment-30584" class="comment not_top_scorer"><div id="post-30584-score" class="comment-score"></div><div class="comment-text"><p>I'm not sure I follow you, but this should probably be a new question in a new topic. This ask.wireshark.org site follows a one-question/answer model, rather than a forum discussion model. Besides, that way I get paid more commission fees. ;)</p></div><div id="comment-30584-info" class="comment-info"><span class="comment-age">(07 Mar '14, 14:32)</span> Hadriel</div></div></div><div id="comment-tools-30531" class="comment-tools"><span class="comments-showing"> showing 5 of 12 </span> <a href="#" class="show-all-comments-link">show 7 more comments</a></div><div class="clear"></div><div id="comment-30531-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

