+++
type = "question"
title = "UDP Port Number"
description = '''I would like to make a dissector in LUA for a protocol thats based on the IEEE 802.15.4 protocol. Its closely enough related that I&#x27;ve been modifying the 802154 dissector in the source code but there are some other things I&#x27;d like to do in a LUA script. In the LUA script I need to specify the UDP po...'''
date = "2017-06-29T12:17:00Z"
lastmod = "2017-06-30T06:33:00Z"
weight = 62419
keywords = [ "udp", "port", "ieee802154" ]
aliases = [ "/questions/62419" ]
osqa_answers = 0
osqa_accepted = false
+++

<div class="headNormal">

# [UDP Port Number](/questions/62419/udp-port-number)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-62419-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-62419-score" class="post-score" title="current number of votes">0</div><span id="post-62419-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span> <span id="favorite-mark" class="ajax-command favorite-mark" rel="nofollow" title="mark/unmark this question as favorite (click again to cancel)"> </span><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>I would like to make a dissector in LUA for a protocol thats based on the IEEE 802.15.4 protocol. Its closely enough related that I've been modifying the 802154 dissector in the source code but there are some other things I'd like to do in a LUA script. In the LUA script I need to specify the UDP port number for the protocol I'm interested in. How do I go about figuring out what UDP port number the IEEE 802.15.4 protocol has as I'd like my lua script to work for that port.</p><p>Thanks</p></div><div id="question-tags" class="tags-container tags"><span class="post-tag tag-link-udp" rel="tag" title="see questions tagged &#39;udp&#39;">udp</span> <span class="post-tag tag-link-port" rel="tag" title="see questions tagged &#39;port&#39;">port</span> <span class="post-tag tag-link-ieee802154" rel="tag" title="see questions tagged &#39;ieee802154&#39;">ieee802154</span></div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>29 Jun '17, 12:17</strong></p><img src="https://secure.gravatar.com/avatar/85e27fa62a7143ddf39c1755e6dc1f42?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="jjamison&#39;s gravatar image" /><p><span>jjamison</span><br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="2 badges"><span class="bronze">●</span><span class="badgecount">2</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="jjamison has no accepted answers">0%</span></p></div></div><div id="comments-container-62419" class="comments-container"><span id="62422"></span><div id="comment-62422" class="comment"><div id="post-62422-score" class="comment-score"></div><div class="comment-text"><p>I'm not sure I understand what exactly you want to achieve. The Lua dissector is invoked by the dissector of a lower layer ("transport") protocol in order to dissect its "payload".</p><p>So you can tell the UDP dissector to invoke your Lua dissector for packets whose source or destination port is a given one, but the Lua dissector itself doesn't need to know the port number at all, it just gets the UDP payload for handling.</p><p>However, if you want the Lua dissector get always invoked but actually do something only if the UDP port is a given one, you can access the already dissected data about the following way (I don't remember it exactly and it is a bit tricky):</p><ul><li>in the initialisation part:</li></ul><p><code>udp_port_extractor = Field.new("udp.port")</code></p><ul><li>in the dissector function itself</li></ul><p><code>local udp_port = udp_port_extractor()</code></p></div><div id="comment-62422-info" class="comment-info"><span class="comment-age">(29 Jun '17, 12:48)</span> <span class="comment-user userinfo">sindy</span></div></div><span id="62424"></span><div id="comment-62424" class="comment"><div id="post-62424-score" class="comment-score"></div><div class="comment-text"><p>Thanks for the quick reply, ok that makes sense. I was just asking for the port number because the lua dissector examples I've seen has a line that says something along the lines of:</p><p>udp_table = DissectorTable.get("udp.port") udp_table:add(XXX, foo_proto)</p><p>How do you go about calling a lua dissector from source dissector?</p></div><div id="comment-62424-info" class="comment-info"><span class="comment-age">(29 Jun '17, 12:55)</span> <span class="comment-user userinfo">jjamison</span></div></div><span id="62425"></span><div id="comment-62425" class="comment"><div id="post-62425-score" class="comment-score"></div><div class="comment-text"><blockquote><p>How do you go about calling a lua dissector from source dissector?</p></blockquote><p>Exactly that way. The Lua script is started once at Wireshark startup and it registers the protocol it can handle (SomeProto), the fields of that protocol, and provides the actual dissection function (SomeProto.dissector() ). And it also <strong>may</strong> register SomeProto (or SomeProto.dissector, it makes no difference) to so-called "dissector table(s)" of its transport protocol(s) dissectors which these dissectors consult when choosing a dissector for their payload. So in your example, the UDP dissector has a table which maps port numbers to payload protocols (or dissectors handling these protocols).</p><p>It <strong>may</strong> register because it is not mandatory, you can also use <code>Decode as...</code> to fill the dissector tables.</p><p>If the UDP port is allocated dynamically, the above method isn't of much use. In this case, you may use the "heuristic dissector" approach, which consists in registering your dissector as a heuristic one for a given transport and writing it in such a way that it either returns 0 if it doesn't "like" the data offered or performs the dissection and returns the whole length of the dissection buffer if it can do that. This way, the transport dissector doesn't care about port numbers but tries the heuristic dissectors one after another until the first one succeeds.</p></div><div id="comment-62425-info" class="comment-info"><span class="comment-age">(29 Jun '17, 13:22)</span> <span class="comment-user userinfo">sindy</span></div></div><span id="62428"></span><div id="comment-62428" class="comment not_top_scorer"><div id="post-62428-score" class="comment-score"></div><div class="comment-text"><p>How do you use Decode as..., is that used in Lua to add it to the proper dissector table automatically? I can't find any documentation on it online.</p><p>Also, Im actually not using the UDP dissector, I'm dissecting IEEE 802.15.4 traffic, I just misunderstood earlier and thought you had to define a UDP port for all lua dissectors regardless of their type.</p><p>Thanks again for your help</p></div><div id="comment-62428-info" class="comment-info"><span class="comment-age">(29 Jun '17, 14:09)</span> <span class="comment-user userinfo">jjamison</span></div></div><span id="62437"></span><div id="comment-62437" class="comment"><div id="post-62437-score" class="comment-score">1</div><div class="comment-text"><p><code>udp_table = DissectorTable.get("udp.port") udp_table:add(XXX, foo_proto)</code> in Lua code is equivalent to choosing an UDP packet with source or destination port XXX in the packet list on GUI and using right-click - Decode as... to choose a payload protocol (or, in another words, its dissector) for port XXX.</p><p>The original IEEE 802.15.4 dissector has a single dissector table named <code>wpan.panid</code> so you may tell it to use your Lua dissector for particular <code>panid</code> values the way described above.</p><p>But maybe I still do not understand what you want to do. I don't know any method of letting Lua code cooperate with C code directly. Lua dissectors can invoke dissectors written in C and vice versa, but having part of the code of a given dissector in C and another part of code of that same dissector in Lua is not possible AFAIK.</p></div><div id="comment-62437-info" class="comment-info"><span class="comment-age">(30 Jun '17, 01:55)</span> <span class="comment-user userinfo">sindy</span></div></div><span id="62442"></span><div id="comment-62442" class="comment not_top_scorer"><div id="post-62442-score" class="comment-score"></div><div class="comment-text"><p>Basically what I'm tyring to do is have a dissector in wireshark that parses through our packets and displays source/desitnation address, panID, sequence number etc and then calls a dissector written in lua that parses the payload. The reason we don't want to write everything in wireshark is because we want to be able to easily edit the payload dissection without having to rebuild the wireshark sources each time. The first part is already done and working, now working on the paylaod dissection in lua.</p></div><div id="comment-62442-info" class="comment-info"><span class="comment-age">(30 Jun '17, 06:03)</span> <span class="comment-user userinfo">jjamison</span></div></div><span id="62444"></span><div id="comment-62444" class="comment"><div id="post-62444-score" class="comment-score">1</div><div class="comment-text"><p>OK, if you can clearly identify part of the protocol data as "payload", you can register your Lua dissector as a dissector for a new distinct "protocol" representing just that payload, and let the modified 802.15.4 invoke it that way. There is a function in C which allows you to fetch a registered dissector and invoke it, but I cannot give you its exact name and parameters as I only write Lua dissectors.</p><p>So you would register your Lua dissector as</p><p><code>SomeProtoPayload = Proto("my_payload","My 802.15.4 payload")</code></p><p>and provide the dissector function itself:</p><p><code>function SomeProtoPayload.dissector(buffer,pinfo,tree)    ... end</code></p><p>In the initialisation part of the C dissector, you would use an equivalent of the following Lua code:</p><p><code>payload_dissector = Dissector.get("my_payload")</code></p><p>And in the dissector function, you would use an equivalent of</p><p><code>payload_dissector(buffer,pinfo,tree)</code></p><p>Some checks (e.g. that fetching the dissector was successful) would be wise.</p><p>The best part of it is that the field names as used in display filters etc. have no relationship to the protocol name, so you can let both the C dissector and the Lua dissector create fields whose names start with the same string (like <code>my_proto.field_x</code>, <code>my_proto.field_y</code>) so for the user there will be no difference between fields contributed by C and fields contributed by Lua.</p></div><div id="comment-62444-info" class="comment-info"><span class="comment-age">(30 Jun '17, 06:33)</span> <span class="comment-user userinfo">sindy</span></div></div></div><div id="comment-tools-62419" class="comment-tools"><span class="comments-showing"> showing 5 of 7 </span> <a href="#" class="show-all-comments-link">show 2 more comments</a></div><div class="clear"></div><div id="comment-62419-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

</div>

