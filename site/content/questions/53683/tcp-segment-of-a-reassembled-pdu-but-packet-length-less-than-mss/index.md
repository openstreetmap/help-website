+++
type = "question"
title = "TCP segment of a reassembled PDU, but packet length less than MSS"
description = '''When I tracked a TCP stream, there is a packet which length is 75 but &quot;TCP segment of a reassembled PDU&quot; showed in WireShark. I searched the mean of &quot;TCP segment of a reassembled PDU&quot;, which only appeared when application data length exceed MSS. So why this happen?  Thanks'''
date = "2016-06-27T23:31:00Z"
lastmod = "2016-06-30T02:26:00Z"
weight = 53683
keywords = [ "mss", "reassemble", "tcp-segment" ]
aliases = [ "/questions/53683" ]
osqa_answers = 1
osqa_accepted = false
+++

<div class="headNormal">

# [TCP segment of a reassembled PDU, but packet length less than MSS](/questions/53683/tcp-segment-of-a-reassembled-pdu-but-packet-length-less-than-mss)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-53683-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-53683-score" class="post-score" title="current number of votes">0</div><span id="post-53683-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span> <span id="favorite-mark" class="ajax-command favorite-mark" rel="nofollow" title="mark/unmark this question as favorite (click again to cancel)"> </span><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>When I tracked a TCP stream, there is a packet which length is 75 but "TCP segment of a reassembled PDU" showed in WireShark. I searched the mean of "TCP segment of a reassembled PDU", which only appeared when application data length exceed MSS. So why this happen? <img src="https://osqa-ask.wireshark.org/upfiles/tcp_reassemable_AbVefgI.png" alt="alt text" /> Thanks</p></div><div id="question-tags" class="tags-container tags"><span class="post-tag tag-link-mss" rel="tag" title="see questions tagged &#39;mss&#39;">mss</span> <span class="post-tag tag-link-reassemble" rel="tag" title="see questions tagged &#39;reassemble&#39;">reassemble</span> <span class="post-tag tag-link-tcp-segment" rel="tag" title="see questions tagged &#39;tcp-segment&#39;">tcp-segment</span></div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>27 Jun '16, 23:31</strong></p><img src="https://secure.gravatar.com/avatar/e4b25ab8b369dffcc57717f43167757f?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="liuanhf&#39;s gravatar image" /><p><span>liuanhf</span><br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="3 badges"><span class="bronze">●</span><span class="badgecount">3</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="liuanhf has no accepted answers">0%</span></p></img></div></div><div id="comments-container-53683" class="comments-container"><span id="53689"></span><div id="comment-53689" class="comment"><div id="post-53689-score" class="comment-score"></div><div class="comment-text"><p>Working from an image makes investigating the question very hard. Can you share a capture in a publicly accessible spot, e.g. <a href="http://cloudshark.org">CloudShark</a>?</p></div><div id="comment-53689-info" class="comment-info"><span class="comment-age">(28 Jun '16, 01:00)</span> <span class="comment-user userinfo">Jaap ♦</span></div></div><span id="53696"></span><div id="comment-53696" class="comment"><div id="post-53696-score" class="comment-score"></div><div class="comment-text"><p>Thank you for your reply, sorry about only one image, please see the answer with me</p></div><div id="comment-53696-info" class="comment-info"><span class="comment-age">(28 Jun '16, 03:55)</span> <span class="comment-user userinfo">liuanhf</span></div></div></div><div id="comment-tools-53683" class="comment-tools"></div><div class="clear"></div><div id="comment-53683-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="53688"></span>

<div id="answer-container-53688" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><span id="post-53688-upvote" class="ajax-command post-vote up" rel="nofollow" title="I like this post (click again to cancel)"> </span><div id="post-53688-score" class="post-score" title="current number of votes">2</div><span id="post-53688-downvote" class="ajax-command post-vote down" rel="nofollow" title="I dont like this post (click again to cancel)"> </span></div></td><td><div class="item-right"><div class="answer-body"><blockquote><p>which only appeared when application data length exceed MSS</p></blockquote><p>It is a misunderstanding. <code>[TCP segment of a reassembled PDU]</code> is shown in the Info column whenever the TCP packet in question contains just a part of the application layer PDU, except the final one, regardless the MSS. The sending side may not make use of the MSS and send shorter packets for whatever reason. So in your case, frames (packets) 148, 150, and 152 contain the complete Ceph PDU.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>28 Jun '16, 00:59</strong></p><img src="https://secure.gravatar.com/avatar/00fc6e2633725bd871ff636f0175eabc?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="sindy&#39;s gravatar image" /><p><span>sindy</span><br />
<span class="score" title="6049 reputation points"><span>6.0k</span></span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="8 badges"><span class="silver">●</span><span class="badgecount">8</span></span><span title="51 badges"><span class="bronze">●</span><span class="badgecount">51</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="sindy has 110 accepted answers">24%</span></p></div><div class="post-update-info post-update-info-edited"><p><span> edited <strong>29 Jun '16, 03:36</strong> </span></p></div></div><div id="comments-container-53688" class="comments-container"><span id="53713"></span><div id="comment-53713" class="comment"><div id="post-53713-score" class="comment-score"></div><div class="comment-text"><p>Thank you very much for your reply. It seems my misunstanding about [TCP segment of a reassembled PDU]. But I still don't know when application will not not make use of the MSS. I've tried a simple server and client program, client sends 3 times to server， but tcp sequences are different. Any hint will be appreciated. Thank you!</p></div><div id="comment-53713-info" class="comment-info"><span class="comment-age">(29 Jun '16, 02:02)</span> <span class="comment-user userinfo">liuanhf</span></div></div><span id="53717"></span><div id="comment-53717" class="comment"><div id="post-53717-score" class="comment-score"></div><div class="comment-text"><blockquote><p>But I still don't know when application will not not make use of the MSS</p></blockquote><p>This is not a question regarding Wireshark (so off-topic on this site) nor a question Wireshark itself could help you answer. Wireshark shows you clearly <strong>what</strong> has happened, but it can tell you <strong>why</strong> it has happened only in a few cases.</p><p>In particular, Wireshark can detect and indicate some protocol errors, but it has no means to find out why applications behave the way they do on a formally correct input.</p><blockquote><p>client sends 3 times to server， but tcp sequences are different</p></blockquote><p>can you elaborate what exactly worries you here?</p><p>TCP sequence numbers must be different for different chunks of data in the same TCP session, it is the cornerstone of TCP handshaking.</p><p>If you have in mind different sessions carrying identical chunks of data, it is still normal that the sequence numbers differ if we talk about absolute sequence numbers - it is also due to the way how TCP works. It is only for convenience of reading that Wireshark uses the sequence number of the first SYN packet as a reference and displays offsets from this value, called relative sequence numbers, in place of the absolute ones.</p></div><div id="comment-53717-info" class="comment-info"><span class="comment-age">(29 Jun '16, 03:51)</span> <span class="comment-user userinfo">sindy</span></div></div><span id="53721"></span><div id="comment-53721" class="comment"><div id="post-53721-score" class="comment-score"></div><div class="comment-text"><p>Oh, sorry, some of my description are not clear.My intention is:<br />
</p><ol><li>I found the ack number of packets(148/150/152) are the same, not the sequence, sorry<br />
</li><li>Wireshark display [TCP segment of a reassembled PDU] may because they have the same ack number<br />
</li><li>I don't know why their length less than MSS but they have the same ack number, so I test my program. "client sends 3 times to server， but tcp sequences are different" is wrong, sorry, I mean ack number are different</li></ol><p>So my question is how this happen -- length less than MSS but ack number are the same, who did this? applicaion layer or IP stack?</p><p>sorry again and hope for your reply</p><p>Thank you very much!</p></div><div id="comment-53721-info" class="comment-info"><span class="comment-age">(29 Jun '16, 04:42)</span> <span class="comment-user userinfo">liuanhf</span></div></div><span id="53722"></span><div id="comment-53722" class="comment"><div id="post-53722-score" class="comment-score"></div><div class="comment-text"><ol><li>this is probably normal (probably because you haven't provided a capture file). Ack value in A-&gt;B direction only changes if some data have been received in B-&gt;A direction, as the Ack value in A-&gt;B direction announces the next expected Seq value of the B-&gt;A direction.</li></ol><p>Example: A sends a packet with Seq=100 and the payload size is 22, which means that the Seq of the next packet from A will be 122. In response, B sends a packet with Ack=122, telling A that it may send that next packet rather than repeating the previous one. If B would send any lower value in Ack (like e.g. 100), most likely after some delay, it would mean that B has not received the packet from A, and that A should re-send the part of data starting from Seq=100.</p><ol><li><p>no, see above. <code>[TCP segment of a reassembled PDU]</code> only means that this TCP packet is other than the last one of an application-layer PDU, as stated in my original Answer. More complex cases do exist, but I don't want to confuse you at this stage; however, rest assured that these cases have nothing to do with the Ack value.</p></li><li><p>if the client sends to server three packets with some payload while the server sends no payload back, Seq should be growing in the packets from client and Ack should be correspondingly growing in the packets from server. Ack in packets from client and Seq in packets from server should not change.</p></li></ol></div><div id="comment-53722-info" class="comment-info"><span class="comment-age">(29 Jun '16, 05:21)</span> <span class="comment-user userinfo">sindy</span></div></div><span id="53742"></span><div id="comment-53742" class="comment"><div id="post-53742-score" class="comment-score"></div><div class="comment-text"><p>Thank you very much.</p><p>1: Yes, you are right, I re-test my program as you mentioned--"the server sends no payload back", the ack numbers of client are not change.</p><p>2: In my program，though ack number are the same, but wireshark does't show [TCP segment of a reassembled PDU], so I think if wireshark show [TCP segment of a reassembled PDU], it must be a session of an applicaton-layer protocal over tcp</p><p>The next step is to find out why tcp segmentation happened although the length of an application-layer protocal less than MSS. May be there are some mechanisms</p><p>Thank you for your patience and guidance</p></div><div id="comment-53742-info" class="comment-info"><span class="comment-age">(29 Jun '16, 22:35)</span> <span class="comment-user userinfo">liuanhf</span></div></div><span id="53746"></span><div id="comment-53746" class="comment not_top_scorer"><div id="post-53746-score" class="comment-score"></div><div class="comment-text"><p>If your test application doesn't use a PDU of some higher layer protocol (which Wireshark can recognize!) as a payload of the TCP packets, i. e. if TCP is the highest dissectable protocol in the TCP stream, and the payload is dissected as just <code>Data</code>, Wireshark will never show <code>[TCP segment of a reassembled PDU]</code> because there is no PDU to be reassembled.</p><p>When you look at packet timestamps (frames 148, 150, and 152 in your screenshot), it is quite likely be that your TCP stack is flushing the Tx buffer more frequently than the application writes the data to the socket. So the application writes the first 9 (75-66) bytes of the PDU to the socket, and before it collects the the next 136 (202-66) bytes to write, the TCP stack decides to send what it has so far.</p><p>You may verify this theory using your test program if it is running on the same machine on which you took your capture, i.e. if it is using the same TCP stack. You would send 20 bytes, then wait for 0.5 ms, and then send another 30 bytes. If you get two packets, that was it; if you get just one with 50 bytes of payload, it is something else. But make sure that these socket writes do not set an equivalent of PSH (push) flag, as in such case the TCP stack <em>must</em> flush the buffer immediately, while your capture doesn't show PSH flags to be present in your <code>[TCP segment of a reassembled PDU]</code> packets.</p></div><div id="comment-53746-info" class="comment-info"><span class="comment-age">(30 Jun '16, 02:26)</span> <span class="comment-user userinfo">sindy</span></div></div></div><div id="comment-tools-53688" class="comment-tools"><span class="comments-showing"> showing 5 of 6 </span> <a href="#" class="show-all-comments-link">show 1 more comments</a></div><div class="clear"></div><div id="comment-53688-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

