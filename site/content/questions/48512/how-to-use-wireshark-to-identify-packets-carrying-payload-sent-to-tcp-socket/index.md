+++
type = "question"
title = "How to use Wireshark to identify packets carrying payload sent to tcp socket?"
description = '''Hello, Here&#x27;s my detailed question: There&#x27;s a Windows C# driver to a Database(which contains the server). I have analysed the client-server communication on Wireshark between these two. How can I know which particular packets are responsible for opening the socket, establishing connection and closin...'''
date = "2015-12-15T01:26:00Z"
lastmod = "2015-12-15T02:33:00Z"
weight = 48512
keywords = [ "tcpip", "socket", "tcp", "wireshark" ]
aliases = [ "/questions/48512" ]
osqa_answers = 2
osqa_accepted = true
+++

<div class="headNormal">

# [How to use Wireshark to identify packets carrying payload sent to tcp socket?](/questions/48512/how-to-use-wireshark-to-identify-packets-carrying-payload-sent-to-tcp-socket)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-48512-score" class="post-score" title="current number of votes">0</div><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>Hello,</p><p>Here's my detailed question: There's a Windows C# driver to a Database(which contains the server). I have analysed the client-server communication on Wireshark between these two. How can I know which particular packets are responsible for opening the socket, establishing connection and closing the socket? My idea is to send the same type of packets from a PLC(Non-windows) to the Database to 'recreate' the driver functionality.</p><p>What I have understood so far: 3-way TCP handshake is necessary for opening a socket.</p></div><div id="question-tags" class="tags-container tags">tcpip socket tcp wireshark</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>15 Dec '15, 01:26</strong></p><img src="https://secure.gravatar.com/avatar/39a5848e53a3c2268c4fc15fd84afe80?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Arjun%20S&#39;s gravatar image" /><p>Arjun S<br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="3 badges"><span class="bronze">●</span><span class="badgecount">3</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Arjun S has no accepted answers">0%</span></p></div><div class="post-update-info post-update-info-edited"><p>edited 15 Dec '15, 04:56</p><img src="https://secure.gravatar.com/avatar/00fc6e2633725bd871ff636f0175eabc?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="sindy&#39;s gravatar image" /><p>sindy<br />
<span class="score" title="6049 reputation points"><span>6.0k</span></span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="8 badges"><span class="silver">●</span><span class="badgecount">8</span></span><span title="51 badges"><span class="bronze">●</span><span class="badgecount">51</span></span></p></div></div><div id="comments-container-48512" class="comments-container"></div><div id="comment-tools-48512" class="comment-tools"></div><div class="clear"></div><div id="comment-48512-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

2 Answers:

</div>

</div>

<span id="48515"></span>

<div id="answer-container-48515" class="answer accepted-answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-48515-score" class="post-score" title="current number of votes">1</div></div></td><td><div class="item-right"><div class="answer-body"><p>3-way tcp handshake is necessary for establishing a tcp session (which, from the client application point of view, is equivalent to opening the socket).</p><p>But after successfully establishing the session, it is necessary to send packets with properly formatted tcp headers to let the tcp session fulfil its purpose of delivering application data sent to the socket. So sending just a couple of properly formatted packets will not do the job. So the first thing you need is a complete tcp stack, not just an ability to send two packets.</p><p>Next, you need to understand the application protocol which uses tcp as transport, so that you could send proper queries to the database and understand the answers.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>15 Dec '15, 01:59</strong></p><img src="https://secure.gravatar.com/avatar/00fc6e2633725bd871ff636f0175eabc?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="sindy&#39;s gravatar image" /><p>sindy<br />
<span class="score" title="6049 reputation points"><span>6.0k</span></span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="8 badges"><span class="silver">●</span><span class="badgecount">8</span></span><span title="51 badges"><span class="bronze">●</span><span class="badgecount">51</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="sindy has 110 accepted answers">24%</span></p></div></div><div id="comments-container-48515" class="comments-container"><span id="48516"></span><div id="comment-48516" class="comment not_top_scorer"><div id="post-48516-score" class="comment-score"></div><div class="comment-text"><p>Thanks for the detailed answer, Sindy.</p><p>I am using a Mongo Database so as you said, I do need to query the database. But not using query commands, rather with the packet data(used for Windows) itself.</p><p>Also, since I am using the Mongo Wire protocol, it says 'Clients should connect to the database with a regular TCP/IP socket. There is no connection handshake.' Since there is no connection handshake for this one, how does it affect the entire thing?</p></div><div id="comment-48516-info" class="comment-info"><span class="comment-age">(15 Dec '15, 02:15)</span> Arjun S</div></div><span id="48519"></span><div id="comment-48519" class="comment"><div id="post-48519-score" class="comment-score">1</div><div class="comment-text"><p>I would understand</p><blockquote><p>Clients should connect to the database with a regular TCP/IP socket. There is no connection handshake.</p></blockquote><p>the way that there is no (need for) connection handshake <em>at application level</em> (the query/answer format/protocol used to talk to the database), because tcp is a reliable transport in terms that it itself takes care about retransmission of eventual lost packets, delivering the bytes of the messages in proper sequence in case that the packets' order swaps in transmission etc.</p><p>So once a tcp session is established (which from the application point of view is equal to successful opening of a socket), you can write your query to the socket, and read back from it the answer, without worrying about reliability of the transmission, because the tcp transport below does that for you.</p><p>That once again leads us to need to have a working tcp stack on the PLC, as without it, you'll simply not be able to send your application queries and receive the answers.</p><p>If there is no tcp stack available for the PLC (possibly due to memory limit or due to complete absence of IP stack, you haven't told us about what the PLC <em>can</em> do at network level), you may need an intermediate box which would understand the protocols which the PLCs already can talk and would act as a mediation gateway to the TCP (or even IP) world, translating the queries in PLC's native protocol to queries to Mongo transported using TCP, and vice versa.</p></div><div id="comment-48519-info" class="comment-info"><span class="comment-age">(15 Dec '15, 02:56)</span> sindy</div></div><span id="48520"></span><div id="comment-48520" class="comment not_top_scorer"><div id="post-48520-score" class="comment-score"></div><div class="comment-text"><p>The PLC has asynchronous function blocks TCP for connecting, sending data, receiving data and finally closing the connection. I have used them in my program to in order to communicate with the Database. But the only hurdle is I cannot query to the database at all, since there is no driver available.</p></div><div id="comment-48520-info" class="comment-info"><span class="comment-age">(15 Dec '15, 03:08)</span> Arjun S</div></div><span id="48521"></span><div id="comment-48521" class="comment"><div id="post-48521-score" class="comment-score">1</div><div class="comment-text"><p>OK, in that case everything seems much simpler. In that case, we come back to the area of using Wireshark to reverse-engineer a protocol and verify our own clone of that protocol.</p><p>When you capture the communication of an existing client with the MongoDB, you can right-click a packet (in the packet list pane) which you know to be part of the session (e.g. the one which says SYN and has the MongoDB IP as source or destination) and then choose Follow -&gt; TCP stream. A new window will pop up, showing you the <strong>payload</strong> of the conversation over that tcp session (it means without the tcp overhead, it means actually the byte streams which an application writes to the socket and reads from it). Switch the "show data as" to "hex dump", and you'll see the queries and answers distinguished by colour and offset from the left. This should help you understand what is missing in your queries that Mongo rejects or ignores, especially if you do the same on a capture taken between your PLC running your code and Mongo and compare the results.</p></div><div id="comment-48521-info" class="comment-info"><span class="comment-age">(15 Dec '15, 03:20)</span> sindy</div></div><span id="48523"></span><div id="comment-48523" class="comment not_top_scorer"><div id="post-48523-score" class="comment-score"></div><div class="comment-text"><p>ah okay, it seems much clearer and that's probably what I was looking for.</p><p>So, I have 2 questions:</p><ol><li><p>Since there are many frames with SYN, should I select just one of them because there are different payload for different frames with SYN in it?</p></li><li><p>Should I check for the payload of the conversation in which only SYN is present or [SYN, ACK] and [ACK] as well?</p></li></ol></div><div id="comment-48523-info" class="comment-info"><span class="comment-age">(15 Dec '15, 04:26)</span> Arjun S</div></div><span id="48524"></span><div id="comment-48524" class="comment"><div id="post-48524-score" class="comment-score">1</div><div class="comment-text"><p>I don't think there's any need to reverse engineer the MongoDb protocol, it's specified <a href="https://docs.mongodb.org/v3.0/reference/mongodb-wire-protocol/">here</a>.</p><p>Wireshark also includes a dissector for MongoDB, so it should be able to show you the packet details straight away, unless you're running MongoDB on another port (other than 27017), in which case you can modify the MongoDB dissector preference for the port you're using.</p></div><div id="comment-48524-info" class="comment-info"><span class="comment-age">(15 Dec '15, 04:30)</span> grahamb ♦</div></div><span id="48525"></span><div id="comment-48525" class="comment"><div id="post-48525-score" class="comment-score">1</div><div class="comment-text"><p>Each tcp session starts from the "three way handshake", which is</p><ol><li><p>the client sends a packet with no payload, SYN bit in flags set to 1, and some (as-if-random) sequence number,</p></li><li><p>the server sends a packet with no payload, ack number matching the sequence number of the previously received packet, and its own, completely unrelated, sequence number, also with SYN bit of flags set to 1</p></li><li><p>the client sends a packet (which already may have a payload but I am not sure here) whose ack number matches the sequence number of the server's sequence number.</p></li></ol><p>Normally, a single tcp session is re-used for more than one request-response pair between a client and a server, but it depends on particular implementation. So if you have, in a relatively short capture, several packets with <code>tcp.flags.syn == 1</code> and the source/destination IP matching the one where the MongoDB is running, you have to look also at tcp port at MongoDB server side and at the other IP (if you capture on the MongoDB server and many clients are connected).</p><p>In any case, the packets with SYN = 1 do not carry any payload, but are easy to identify and a good base for "follow tcp stream".</p></div><div id="comment-48525-info" class="comment-info"><span class="comment-age">(15 Dec '15, 04:34)</span> sindy</div></div><span id="48526"></span><div id="comment-48526" class="comment not_top_scorer"><div id="post-48526-score" class="comment-score"></div><div class="comment-text"><p>Grahamb,</p><p>Yes, I am running the DB on 27017. The different fields inside the Structure Message Header appear on the Wireshark pane. Now that I have those, I can compare the field values of the Windows driver with those of PLC and see where it is going.</p><p>Thank you very much. :)</p></div><div id="comment-48526-info" class="comment-info"><span class="comment-age">(15 Dec '15, 04:54)</span> Arjun S</div></div><span id="48527"></span><div id="comment-48527" class="comment not_top_scorer"><div id="post-48527-score" class="comment-score"></div><div class="comment-text"><p>Sindy,</p><p>You said 'you have to look also at tcp port at MongoDB server side'. I am only checking the connections from the client side via Wireshark. Is it a necessity to check on the server side as well or can I check it from the client computer itself? And there is only 1 client and 1 server involved.</p></div><div id="comment-48527-info" class="comment-info"><span class="comment-age">(15 Dec '15, 05:03)</span> Arjun S</div></div><span id="48528"></span><div id="comment-48528" class="comment"><div id="post-48528-score" class="comment-score">1</div><div class="comment-text"><p>I've said that in a context where you've complained about many packets matching display filter <code>tcp.flags.syn == 1</code> in your capture. It is enough to capture on the client computer, and applying a <strong>display filter</strong> <code>tcp.flags.syn == 1 and tcp.dstport == 27017</code> should be sufficient to tell whether just a single tcp session has been established between the client PC and the server during the capture, or more than one. But even if there are several such packets in a capture from successful communication, any of them can be used to "follow tcp stream" (which will replace the display filter with <code>tcp.stream == xx</code>), as for your purpose there is little difference between the sessions.</p><p>When capturing to debug your PLC application (probably on the server, with <strong>capture filter</strong> set to <code>host ip.add.re.ss</code>, where ip.add.re.ss is the IP of your PLC device), you should see the three-way handshake to complete successfully first, and if this is true, you should see also some packet(s) whose protocol name in the packet list is "MONGO", because it carries some payload and the source or destination tcp port is 27017. These two conditions should be enough for the mongo dissector to kick in, although what you send may be a garbage yet.</p></div><div id="comment-48528-info" class="comment-info"><span class="comment-age">(15 Dec '15, 05:20)</span> sindy</div></div><span id="48529"></span><div id="comment-48529" class="comment not_top_scorer"><div id="post-48529-score" class="comment-score"></div><div class="comment-text"><p>This answer helped me a lot to understand about the payload. Thanks a lot for your valuable time. :)</p></div><div id="comment-48529-info" class="comment-info"><span class="comment-age">(15 Dec '15, 05:52)</span> Arjun S</div></div></div><div id="comment-tools-48515" class="comment-tools"><span class="comments-showing"> showing 5 of 11 </span> <a href="#" class="show-all-comments-link">show 6 more comments</a></div><div class="clear"></div><div id="comment-48515-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<span id="48517"></span>

<div id="answer-container-48517" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-48517-score" class="post-score" title="current number of votes">1</div></div></td><td><div class="item-right"><div class="answer-body"><p>Can you be more specific about what you're trying to do with your DB? TCP 3-way handshake is not normally something a DB programmer will be concerned with.</p><p>On Windows programmers would generally use an ODBC driver, or possibly a DB specific driver. The driver abstracts out all the low-level details such as TCP handshake and allows the programmer to concentrate on their task of querying the db.</p><p>For C#, there is a MongoDB driver available <a href="https://docs.mongodb.org/ecosystem/drivers/csharp/">here</a>.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>15 Dec '15, 02:33</strong></p><img src="https://secure.gravatar.com/avatar/d2a7e24ca66604c749c7c88c1da8ff78?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="grahamb&#39;s gravatar image" /><p>grahamb ♦<br />
<span class="score" title="19834 reputation points"><span>19.8k</span></span><span title="3 badges"><span class="badge1">●</span><span class="badgecount">3</span></span><span title="30 badges"><span class="silver">●</span><span class="badgecount">30</span></span><span title="206 badges"><span class="bronze">●</span><span class="badgecount">206</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="grahamb has 274 accepted answers">22%</span></p></div></div><div id="comments-container-48517" class="comments-container"><span id="48518"></span><div id="comment-48518" class="comment"><div id="post-48518-score" class="comment-score"></div><div class="comment-text"><p>Thanks for the reply, Grahamb. :)</p><p>I want to insert documents from a PLC into MongoDB(NoSQL) <em>but</em> the PLC doesn't have a driver for MongoDB which is why I looked at the socket communication for client and MongoDB using C# to get a rough idea.</p><p>Since there is no driver at all, is it possible to send the same packets for opening a socket, connecting, closing, et al as seen on Wireshark from a PLC to DB as a string, maybe?</p></div><div id="comment-48518-info" class="comment-info"><span class="comment-age">(15 Dec '15, 02:42)</span> Arjun S</div></div></div><div id="comment-tools-48517" class="comment-tools"></div><div class="clear"></div><div id="comment-48517-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

