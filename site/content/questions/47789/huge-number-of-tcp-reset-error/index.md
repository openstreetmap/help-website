+++
type = "question"
title = "Huge Number of TCP Reset Error"
description = '''Hi All, I&#x27;m Facing huge number of TCP Reset Errors at my network. I am not in depth familiar with TCP and its behavior so i&#x27;ve attached a screenshot of packet capture. I want you to analyze it and tell me what you guys observe any abnormalities that could lead to any abnormal behavior. The Problem i...'''
date = "2015-11-20T05:42:00Z"
lastmod = "2015-11-20T06:20:00Z"
weight = 47789
keywords = [ "reset", "tcp", "error" ]
aliases = [ "/questions/47789" ]
osqa_answers = 0
osqa_accepted = false
+++

<div class="headNormal">

# [Huge Number of TCP Reset Error](/questions/47789/huge-number-of-tcp-reset-error)

</div>

<div id="main-body">

<div id="askform">

<table id="question-table" style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-47789-score" class="post-score" title="current number of votes">0</div><div id="favorite-count" class="favorite-count"></div></div></td><td><div id="item-right"><div class="question-body"><p>Hi All,</p><p>I'm Facing huge number of TCP Reset Errors at my network. I am not in depth familiar with TCP and its behavior so i've attached a screenshot of packet capture. I want you to analyze it and tell me what you guys observe any abnormalities that could lead to any abnormal behavior.</p><p>The Problem is our web server getting 6000-10000 hits per seconds, yes it is that high. and around 20000 connection goes to tcp Time-wait state right now. So problems we are facing is Client getting RTO at number of requests (is should be responded under max 3 seconds), we are re-transmitting numerous number of packets and this RESET we are getting from client. although our bandwidths are ideal for this kind of traffic so there is no problem.</p><p>Here is the packet trace !<img src="http://i63.tinypic.com/2luc7ir.jpg" alt="TRACE ALT" /> At first i want to cut down the RESETs.</p><p>Please help guys, i need to solve it very soon. if you need anymore information i'm ready to share it ..</p><p>Thanks Arjun</p><p><a href="http://i63.tinypic.com/2luc7ir.jpg">http://i63.tinypic.com/2luc7ir.jpg</a></p></div><div id="question-tags" class="tags-container tags">reset tcp error</div><div id="question-controls" class="post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>asked <strong>20 Nov '15, 05:42</strong></p><img src="https://secure.gravatar.com/avatar/8e4593574ae62f4a91ddf7331b2a5525?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="Arjun%20Singh&#39;s gravatar image" /><p>Arjun Singh<br />
<span class="score" title="6 reputation points">6</span><span title="1 badges"><span class="badge1">●</span><span class="badgecount">1</span></span><span title="1 badges"><span class="silver">●</span><span class="badgecount">1</span></span><span title="3 badges"><span class="bronze">●</span><span class="badgecount">3</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="Arjun Singh has no accepted answers">0%</span></p></img></div><div class="post-update-info post-update-info-edited"><p>edited 20 Nov '15, 05:43</p></div></div><div id="comments-container-47789" class="comments-container"><span id="47842"></span><div id="comment-47842" class="comment"><div id="post-47842-score" class="comment-score"></div><div class="comment-text"><p>Your Question is similar to this question: <a href="https://ask.wireshark.org/questions/41982/bad-ack-response-to-syn?page=1&amp;focusedAnswerId=41993#41993">https://ask.wireshark.org/questions/41982/bad-ack-response-to-syn?page=1&amp;focusedAnswerId=41993#41993</a></p></div><div id="comment-47842-info" class="comment-info"><span class="comment-age">(21 Nov '15, 12:15)</span> Christian_R</div></div></div><div id="comment-tools-47789" class="comment-tools"></div><div class="clear"></div><div id="comment-47789-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

------------------------------------------------------------------------

<div class="tabBar">

<span id="sort-top"></span>

<div class="headQuestions">

One Answer:

</div>

</div>

<span id="47790"></span>

<div id="answer-container-47790" class="answer">

<table style="width:100%;"><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><tbody><tr class="odd"><td style="width: 30px; vertical-align: top"><div class="vote-buttons"><div id="post-47790-score" class="post-score" title="current number of votes">0</div></div></td><td><div class="item-right"><div class="answer-body"><p>From the screenshot alone it seems that the http server assumes that the tcp connection has been already established from the same source socket before, but not properly closed yet, and so it sends only ACK to the received SYN but not its own SYN.</p><p>For deeper analysis, you'd have to post .pcap (or .pcapng) capture files from both the http server side and from a client PC accessing the web taken simultaneously for some time &amp; including occurrence of the issue for that client. As your artwork at the picture suggests that you are concerned about privacy, you may want to anonymize the captures using <a href="https://www.tracewrangler.com/">TraceWrangler</a> before handing them out.</p><p>Or read <a href="http://stackoverflow.com/questions/8893888/dropping-of-connections-with-tcp-tw-recycle">this answer on another site</a> and take the measures suggested there.</p></div><div class="answer-controls post-controls"></div><div class="post-update-info-container"><div class="post-update-info post-update-info-user"><p>answered <strong>20 Nov '15, 06:20</strong></p><img src="https://secure.gravatar.com/avatar/00fc6e2633725bd871ff636f0175eabc?s=32&amp;d=identicon&amp;r=g" class="gravatar" width="32" height="32" alt="sindy&#39;s gravatar image" /><p>sindy<br />
<span class="score" title="6049 reputation points"><span>6.0k</span></span><span title="4 badges"><span class="badge1">●</span><span class="badgecount">4</span></span><span title="8 badges"><span class="silver">●</span><span class="badgecount">8</span></span><span title="51 badges"><span class="bronze">●</span><span class="badgecount">51</span></span><br />
<span class="accept_rate" title="Rate of the user&#39;s accepted answers">accept rate:</span> <span title="sindy has 110 accepted answers">24%</span></p></div><div class="post-update-info post-update-info-edited"><p>edited 20 Nov '15, 07:00</p></div></div><div id="comments-container-47790" class="comments-container"><span id="47810"></span><div id="comment-47810" class="comment"><div id="post-47810-score" class="comment-score"></div><div class="comment-text"><p>thanks sindy for the reply and anonymizer tool,</p><p>**if i'm understanding correctly are you saying that client machine has unclosed socket at his end and my server trying to reconnect to that socket? another question is it normal if we get SYN in middle of TCP session after Handshake process, like shouldn't it be the part of early stages only (3-Way handshake). I'm providing my side of pcap for now. we have requested the client to match the timings for pcap. but can you take a look and help me understand what the problem is?</p><p>10.10.10.10 - Client</p><p>10.248.187.181 - Our HTTP server**</p><p><a href="http://s000.tinyupload.com/index.php?file_id=15001899961004530749">Pcap File</a></p></div><div id="comment-47810-info" class="comment-info"><span class="comment-age">(20 Nov '15, 12:27)</span> Arjun Singh</div></div><span id="47813"></span><div id="comment-47813" class="comment not_top_scorer"><div id="post-47813-score" class="comment-score"></div><div class="comment-text"><p>You are right that the SYN should come only once in the beginning of session, yet I am not a TCP expert either. But:</p><ul><li>any packet in any direction may be lost and thus retransmitted, and the travel time of any two packets between the same source and destination may differ significantly. So you cannot exclude that the initial SYN would come twice or more times if your first SYN+ACK has not reached the session initiator fast enough. And due to the variable delay, you may have already ACKed a received SYN, the remote party may have received your ACK and sent to you the first data packet (or even more as ACK for every single packet is not mandatory), and still a SYN retransmission may arrive.</li><li>the ACK is not just a boolean value (nothing like NAK exists in tcp); instead, the sender of the ACK indicates to the remote party the order number of the byte it has successfully received.</li></ul><p>So open your anonymized capture and use display filter <code>(ip.src == 10.10.10.10 and tcp.srcport == 44157 and tcp.dstport == 80) or (tcp.srcport == 80 and tcp.dstport == 44157 and ip.dst == 10.10.10.10)</code>. You shall see that</p><ul><li>the first tcp session has started with a SYN in frame 61303 and ended with ACK to FIN in frames 61315, 61316.</li><li>it then took about 32 seconds until the client side has used the same socket for a new session starting with SYN in frame 101255 and ending with ACK to FIN in frames 101333, 101334.</li><li>and it took another about 36 seconds until another SYN has arrived from the same socket - frame 148368, which has been evaluated as part of the previous session and as such ACKed with a local sequence number from that session, which the client has evaluated as an error and has responded with an RST.</li></ul><p>I was looking for some difference between the two cases and it is not very convincing:</p><ul><li>the <em>absolute</em> sequence number in frame 101255 was 0x90ab3f05 which is slightly lower than sequence number 0x91d3af78 of the FIN frame 61315,</li><li>the <em>absolute</em> sequence number in frame 148368 was 0x4b081d10 which is much lower than sequence number 0x90ab44f3 of the FIN frame 101334.</li></ul><p>So we can see that the tcp stack in your server treats the two quite similar cases differently but I don't dare to guess why exactly.</p><p>... to be continued</p></div><div id="comment-47813-info" class="comment-info"><span class="comment-age">(20 Nov '15, 13:25)</span> sindy</div></div><span id="47814"></span><div id="comment-47814" class="comment not_top_scorer"><div id="post-47814-score" class="comment-score"></div><div class="comment-text"><p>I wanted the capture from client side because I've expected to see some lost FIN packets, and I also didn't know you knew the public IP address of your client. As it looks now, the capture from their side won't bring too much additional information.</p><p>My opinion is that you have to try to use the settings suggested at the link I've sent you before and hope that they help, because otherwise you would have to (let someone?) dive deep into the tcp stack of your server's kernel and change its treatment of remote socket reuse.</p></div><div id="comment-47814-info" class="comment-info"><span class="comment-age">(20 Nov '15, 13:47)</span> sindy</div></div><span id="47817"></span><div id="comment-47817" class="comment not_top_scorer"><div id="post-47817-score" class="comment-score"></div><div class="comment-text"><p>Hm, I am afraid you <em>will</em> need a kernel recompilation... see <a href="http://mailman.nanog.org/pipermail/nanog/2012-December/054013.html">this thread</a> for explanation why.</p><p>In short, the window during which the kernel tcp stack still treats new packets from the same socket as late arrivals is 60 seconds and it is not configurable: net/tcp/tcp.h says</p><p><code>#define TCP_TIMEWAIT_LEN 6000 /* How long to wait to sucessfully close the socket, about 60 seconds. */</code></p><p>And please do not ask me why your server does not have the same issue with the first reuse in the capture.</p><p>Your other option would be not to touch the server and insert a load balancer in front of it, which would spread the traffic among several servers or, if you feel brave, just among several ports of your current server to which you would attach the httpd.</p><p>The assumption is that a load balancer's tcp stack should be better prepared for this (or not stateful, just passing the packets through while changing the tcp port number) so at each of the server's sockets, the SYN of the next connection would not arrive earlier than 60 seconds after the FIN/ACK/FIN/ACK of the previous one.</p><p>And maybe the simplest to implement if you encounter the issue only with that single client: could you ask them to use more public addresses at their NAT device? Looking at the reuse rate in this capture, three public IPs should be enough to get rid of the problem. If they would also broaden the range of ports the NAT device is allowed to use (the capture shows that they use a range from 39xxx through 60xxx, which quite matches your 20000 connections in TIME WAIT state), just two public IPs would be enough for the traffic volume seen in the capture.</p><p>Yet not knowing the client application, I cannot predict whether if the connections would stop failing, their total count would decrease because less retries would be necessary, or whether it would increase because the client would be able to pass more requests through the (then wider) bottleneck of their NAT device.</p></div><div id="comment-47817-info" class="comment-info"><span class="comment-age">(20 Nov '15, 14:52)</span> sindy</div></div><span id="47843"></span><div id="comment-47843" class="comment not_top_scorer"><div id="post-47843-score" class="comment-score"></div><div class="comment-text"><p>thanks for the analysis sindy, i'm going through it and trying to understand our feasible solution. Few questions</p><ol><li><p>we are using loadbalancer HAproxy. just wanna understand in this case loadbalancer will temporarily keep all tcp segements in own buffer, and after confirming all timers, sequence, out of order frames. it will forward to server? is it how it will work?</p></li><li><p>another solution might be asking the client to extend the port numbers range (1025 - 65534). to overcome reuse problem.</p></li><li><p>TIMEWAIT is interesting.. wanna know is it TCP_TW_REUSE? both are same? altering this key might solve socket exhaustion problem but i think it will increase the resets.</p></li></ol><p>what your say?</p></div><div id="comment-47843-info" class="comment-info"><span class="comment-age">(21 Nov '15, 20:15)</span> Arjun Singh</div></div><span id="47844"></span><div id="comment-47844" class="comment not_top_scorer"><div id="post-47844-score" class="comment-score"></div><div class="comment-text"><p>"and it took another about 36 seconds until another SYN has arrived from the same socket - frame 148368, which has been evaluated as part of the previous session and as such ACKed with a local sequence number from that session, which the client has evaluated as an error and has responded with an RST."</p><p>within 75 seconds i see this socket used three times.. why? and i have a question. isn't SYN = LAST RECEIVED ACK or 0? so lets say we generated 3 SYN for a session and our server responded to second one, the 1st one lingering in the path. now i wanna know the SEQ NUM for all SYN would be same or different? if it is same then isn't any mechanism in TCP STACK where it can reject the already ACKed SYN by checking SEQ number. and if all 3 SYN are different then wouldn't it be considered as 3 different connections? hmm... i'm thinking SACK. but its already ON.</p></div><div id="comment-47844-info" class="comment-info"><span class="comment-age">(21 Nov '15, 20:28)</span> Arjun Singh</div></div><span id="47846"></span><div id="comment-47846" class="comment not_top_scorer"><div id="post-47846-score" class="comment-score"></div><div class="comment-text"><p>I say few responses:</p><ol><li><p>We are at Wireshark Q&amp;A, aren't we. So take a capture on the machine running the HAProxy (simultaneously on all interfaces that may be involved) and you'll see the answer. Or ask the HAProxy authors. I could only suppose. But your mentioning of HAProxy changes a lot of things. <strong>Where exactly the capture you've posted has been taken?</strong> Between the client and HAProxy or between HAProxy and the server? Maybe the 20000 ports pool is set on your HAProxy and not on the client side? Can you provide a drawing of the complete architecture of your site (covering the whole path between the interface providing connection to the internet and the server)?</p></li><li><p>yes, that is why I've recommended already, but it may not be enough, as I've also already written: Currently, the machine from which the requests are coming is cyclically reusing some 20000 ports. If they start using a pool of 63000 ports, it may solve the problem of mistreatment of new sessions, but only if it is the only problem in the whole chain. Because the capture on your end only shows the requests that made it from the real client to your server through the limitation of the 20000 available ports somewhere between the real client and your server. There may have been a ton of connection attempts that have been rejected already at client side due to unavailability of free port, and these would reach your site after the number of ports would get tripled.</p></li></ol></div><div id="comment-47846-info" class="comment-info"><span class="comment-age">(22 Nov '15, 01:49)</span> sindy</div></div><span id="47847"></span><div id="comment-47847" class="comment"><div id="post-47847-score" class="comment-score">1</div><div class="comment-text"><p>\3. No, they are not the same.<br />
</p><ul><li><p><code>TIME_WAIT</code> is a state of a state automaton.</p></li><li><p><code>TCP_TIMEWAIT_LEN</code> is a constant in the source code defining for how long the state automaton should remain in TIME_WAIT state, but it seems it can actually be overridden by setting <code>tcp_fin_timeout</code>.</p></li><li><p><code>tcp_tw_reuse</code> is a "boolean" value (0/1) changing the way how the tcp stack treats SYN packets coming from a remote socket in <code>TIME_WAIT</code> state.</p></li></ul><p>Look <a href="http://www.speedguide.net/articles/linux-broadband-tweaks-121">here</a> for details. So try the following step, or both if necessary, on the machine which has been anonymized to 10.248.187.181:</p><ul><li><p>Use<br />
<code>cat /proc/sys/net/ipv4/tcp_fin_timeout</code><br />
and if it returns 60, do<br />
<code>echo 15 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</code><br />
and see whether it becomes better.</p></li><li><p><strong>Only if it does not help</strong>, your next try would be<br />
<code>cat /proc/sys/net/ipv4/tcp_tw_reuse</code><br />
and if it returns 0, use <code>echo 1 &gt; /proc/sys/net/ipv4/tcp_tw_reuse</code> to effectively override the TIME_WAIT state, so if a late packet from the previous session would come, it would be treated as part of the new session and corrupt it.</p></li></ul></div><div id="comment-47847-info" class="comment-info"><span class="comment-age">(22 Nov '15, 01:50)</span> sindy</div></div><span id="47848"></span><div id="comment-47848" class="comment not_top_scorer"><div id="post-47848-score" class="comment-score"></div><div class="comment-text"><blockquote><p>within 75 seconds i see this socket used three times.. why?</p></blockquote><p>because during that 75 seconds, the available pool of ~20000 sockets has been cycled through three times, i.e. the client(s) has attempted to open (at least!) ~60000 tcp sessions during that time. At least because there may have been even more attempts but we cannot see them as they haven't made it through the 20000 ports limit.</p><blockquote><p>now i wanna know the SEQ NUM for all SYN would be same or different?</p></blockquote><p>See <a href="https://tools.ietf.org/html/rfc793">the TCP RFC</a>, but I haven't found anything regarding treatment of mid-session SYN there. In any case, the very meaning of a SYN indicator set to 1 in a packet is to declare that the <em>absolute</em> SEQ NUM in that packet is the initial (reference) sequence number for the session, i.e. a <em>relative</em> 0. So it would be a very bad idea to use different <em>absolute</em> SEQ NUM in the retransmissions of this packet.</p></div><div id="comment-47848-info" class="comment-info"><span class="comment-age">(22 Nov '15, 02:53)</span> sindy</div></div><span id="47849"></span><div id="comment-47849" class="comment not_top_scorer"><div id="post-47849-score" class="comment-score"></div><div class="comment-text"><p>Just out of curiosity have you set tw_recycle =1? Maybe it has been written here, then I missed it.</p><p>Personal I do think, the smartest solution is to add one or more client IP's as @sindy suggested, because it is independent of operating system implementations.</p><p>But here is another nice article: <a href="http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#netipv4tcp_tw_recycle">http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#netipv4tcp_tw_recycle</a></p></div><div id="comment-47849-info" class="comment-info"><span class="comment-age">(22 Nov '15, 03:05)</span> Christian_R</div></div><span id="47850"></span><div id="comment-47850" class="comment not_top_scorer"><div id="post-47850-score" class="comment-score"></div><div class="comment-text"><p>@arjun-singh, forget what I wrote about tcp_tw_reuse. It is only relevant to outgoing session which is not your case. <a href="http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#netipv4tcp_tw_recycle">The article</a> which @Christian_R has mentioned gives a much clearer view than <a href="http://www.speedguide.net/articles/linux-broadband-tweaks-121">the one I've given before</a>. I even doubt whether I've understood properly the meaning of tcp_fin_timeout.</p><p>@Christian_R, in the great article you've mentioned (I think one would have a hard time trying to find something to add to it, thank you for the link!) there is one important paragraph related to use of tcp_tw_recycle:</p><blockquote><p>When the remote host is in fact a NAT device, the condition on timestamps will forbid all of the hosts except one behind the NAT device to connect during one minute because they do not share the same timestamp clock. In doubt, this is far better to disable this option since it leads to difficult to detect and difficult to diagnose problems.</p></blockquote><p>So until @arjun_singh tells us whether there is a NAT on client side, we cannot say whether use of tcp_tw_recycle would help or actually make it worse.</p></div><div id="comment-47850-info" class="comment-info"><span class="comment-age">(22 Nov '15, 03:57)</span> sindy</div></div><span id="47888"></span><div id="comment-47888" class="comment not_top_scorer"><div id="post-47888-score" class="comment-score"></div><div class="comment-text"><p>client agreed upon sharing captures...so will revert soon... in the meantime i'm sharing topology at our end.</p><p><a href="http://s000.tinyupload.com/?file_id=98475239441193171483">http://s000.tinyupload.com/?file_id=98475239441193171483</a></p></div><div id="comment-47888-info" class="comment-info"><span class="comment-age">(23 Nov '15, 13:23)</span> Arjun Singh</div></div><span id="47897"></span><div id="comment-47897" class="comment"><div id="post-47897-score" class="comment-score">1</div><div class="comment-text"><p>OK, so at least we know that the limited pool of ports is at customer side, not yours, because you've taken the capture between your border router and the load balancer's "outer" side.</p><p>The client's topology is important. I now bet that there is a NAT at their side, and also that your HAProxy has tcp_tw_recycle enabled, because I had a look at the tcp option timestamp after all. Still looking at the three tcp sessions coming to us from port 44157, I can see the following timestamps in the SYN packets establishing them:<br />
3925502261<br />
3925511625<br />
3925426321<br />
As the second one is higher than the first, the load balancer has recognized it as part of new session, so it has responded with a SYN, ACK for a new session; as the third is lower than the second, it<br />
a) means that this third request actually comes from a different machine than the second one,<br />
b) caused the HAProxy answer with plain ACK for the existing session (probably not "thinking" deep enough to notice that the timestamp is so low that it cannot be a late packet from the session in TIME_WAIT state).</p><p>So we can now be almost sure that tcp_tw_recycle is enabled at the HAProxy, but as part of the solution it has to be disabled, in order to permit clients behind customer's NAT to get through. Disabling tcp_tw_reuse will imply a need for a guard time &gt; 60 seconds before reuse of the socket pair (local ip:local port, remote ip:remote port) for a new session. So without extending the number of IP addresses and/or ports on client side or on our side, it will be even worse.</p><p>If neither you nor the client can extend the number of public IP addresses, try to agree with the customer on assignment of maximum possible pool of ports (1025-65534) at their NAT and see whether it is enough or not.</p><p>In theory, extending the number of ports at your side would help too, but I have no idea how to make the client's web browsers evenly distribute the http requests among several ports at your side as neither Google Chrome nor Mozilla Firefox use SRV DNS records up till now :-(</p><p>So if the maximum possible pool of ports at customer side is still not enough, in my opinion only two possibilities remain:</p><ul><li><p>to migrate to IPv6</p></li><li><p>to set up a VPN between you and the customer so that the customer's pool of "outer" addresses on customer's NAT box could be augmented with a couple of private addresses. Details on request.</p></li></ul></div><div id="comment-47897-info" class="comment-info"><span class="comment-age">(23 Nov '15, 14:46)</span> sindy</div></div><span id="47955"></span><div id="comment-47955" class="comment not_top_scorer"><div id="post-47955-score" class="comment-score"></div><div class="comment-text"><p>hi guys, first of all thank you for being with me..</p><p>last night we face sudden surge of <strong>spurious re-transmission</strong> on our both servers. I got hands on live captures for both side. After analysing it i found that sindy was right client has NAT enabled.. 'cos i'm seeing private ip in capture. but i didn't allowed tcp_tw_recycle and its value is 0 on our loadbalancer.. I'm attaching both captures here.. please have a look..<br />
our ip_local_port_range is 32768-61000,<br />
tcp_tw_recycle = 0<br />
tcp_tw_reuse =<br />
tcp_fin_timeout = 60</p><p>Our capture &gt;&gt; <a href="http://www93.zippyshare.com/v/zd8f670O/file.html">http://www93.zippyshare.com/v/zd8f670O/file.html</a></p><p>Client Capture &gt;&gt; <a href="http://www93.zippyshare.com/v/busirUxE/file.html">http://www93.zippyshare.com/v/busirUxE/file.html</a></p><p><strong>10.10.10.10 &gt;&gt;&gt; client public IP<br />
10.248.187.181 &gt;&gt; Our Internal IP (private)<br />
192.168.201.56 &gt;&gt; client Internal IP (private)<br />
50.60.70.80 &gt;&gt; Our Public IP</strong><br />
</p><p>@Sindy we tried with VPN first place, but it didn't work out. there were much more timeouts than public. but my first priority is VPN and i'll go for it after this issue get solved. I'm putting IP address / Port range extension suggestion on table tonight. so Lets see.. :) till then can you guys tell me why these spurious tranmission happend?? it came suddenly for 5 mins then again everything went normal.</p><p>My another question which answer i couldn't find anywhere in your links clearly is, in tcp_tw_reuse server can reuse the ports in TIME_WAIT state, now if a current session is not over and a socket is reused with new request how tcp gonna know that its NEW not OLD one when its session is still running (in TIME_WAIT counter). and if i say timestamps, then how can we so sure about synchronization of time stamps of thrice servers, as you already quoted a 3 timestamp mismatch.. where our LB got confused?</p><p>thanks</p></div><div id="comment-47955-info" class="comment-info"><span class="comment-age">(25 Nov '15, 02:25)</span> Arjun Singh</div></div><span id="47957"></span><div id="comment-47957" class="comment not_top_scorer"><div id="post-47957-score" class="comment-score"></div><div class="comment-text"><p>Hi Arjun, I cannot download huge captures on the road, but to answer your questions which don't require analysis of the new captures:</p><blockquote><p>in tcp_tw_reuse server can reuse the ports in TIME_WAIT state</p></blockquote><p>let's remind that a "server" can have two meanings:</p><ul><li><p>a role in a session (a "client" is the party which actively opens the session, i.e. sends the initial SYN in case of tcp session, while a "server" is the party which receives the initial SYN and responds with SYN, ACK)</p></li><li><p>a powerful hardware intended to serve service requests from many clients.</p></li></ul><p>Having said that: I understand the <a href="http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html">article</a> found by @Christian_R that tcp_tw_reuse is only meaningful for a tcp session client, as it permits it to open a new session towards the same remote socket from the same local socket while the previous session using that socket pair is still in TIME_WAIT state. In another words, enabling tcp_tw_reuse has no effect on sessions coming to your servers from tcp clients. Going deeper into it (an <em>not</em> related to your current investigation), tcp_tw_reuse on client side without knowing that tcp_tw_recycle is enabled on the server side is a bad idea because an attempt of the client with tcp_tw_reuse enabled to establish a session reusing the same socket pair will fail if tcp_tw_recycle is not enabled at the server side. Make your own conclusion about how useful these settings actually are, given that they apply for the whole tcp stack and cannot be narrowed to apply only to a list of remote IP addresses.</p></div><div id="comment-47957-info" class="comment-info"><span class="comment-age">(25 Nov '15, 03:31)</span> sindy</div></div><span id="47962"></span><div id="comment-47962" class="comment"><div id="post-47962-score" class="comment-score">1</div><div class="comment-text"><blockquote><p>we tried with VPN first place, but it didn't work out. there were much more timeouts than public.</p></blockquote><p>I'd like to draw your attention to what I wrote before: it is possible that the NAT at customer side is actually throttling the number of their workstations' requests which reach you, so while the VPN was in use, from customer perspective there may have been no difference while there was from your perspective (more session establishment requests made it from the client's workstations to your load balancer so you could see more tcp resets than now).</p><p>Now if your servers and some of the client's network elements are e.g. in the same datacenter, or you can organize a direct communication channel between your border router and the client's network some other way, you may even not need a VPN to tunnel the connection of their network to your border router through public internet. To get id of the tcp reset issue, it is enough to use a NAT which hides the IP addresses of the customer's network behind a couple of private addresses which are not used in your own network. This NAT may be set up on their end as well as at your end.</p></div><div id="comment-47962-info" class="comment-info"><span class="comment-age">(25 Nov '15, 03:57)</span> sindy</div></div><span id="48026"></span><div id="comment-48026" class="comment not_top_scorer"><div id="post-48026-score" class="comment-score"></div><div class="comment-text"><p>sindy?? how moving to iPv6 gonna help us. I changed the tcp_fin_timeout at our LB to 10. i'm analyzing the traffic, but couldn't see much effect.</p></div><div id="comment-48026-info" class="comment-info"><span class="comment-age">(27 Nov '15, 08:09)</span> Arjun Singh</div></div><span id="48028"></span><div id="comment-48028" class="comment not_top_scorer"><div id="post-48028-score" class="comment-score"></div><div class="comment-text"><p>@Arjun Singh</p><p>Your "answer" has been converted to a comment as that's how this site works. Please read the FAQ for more information.</p></div><div id="comment-48028-info" class="comment-info"><span class="comment-age">(27 Nov '15, 08:25)</span> grahamb ♦</div></div><span id="48034"></span><div id="comment-48034" class="comment"><div id="post-48034-score" class="comment-score">1</div><div class="comment-text"><p>@Arjun-Singh, I guess I may have even misunderstood the meaning of tcp_fin_timeout as well, so let's forget about it.</p><p>As for IPv6, the idea behind is that NAT would not be necessary because an IPv6 address is not as scarce resource as an IPv4 public address - IPv6 addresses are allocated to customers in blocks of /64 subnets. So the tcp sessions would be established between your load balancer and individual workstations' addresses at customer side. So each workstation at customer side would be able to use ~ 60000 tcp ports instead of fighting against all the others for the same ~ 60000 ports at the public side of the NAT device. That would allow for port reuse rate of 16 sessions per second (which means ~ 60000 sessions per 60 seconds which is the TIME_WAIT duration) at client side without need to use tcp_tw_recycle on load balancer side and tcp_tw_reuse on workstation side.</p><p>But as I started digging further (to find out that while TIME_WAIT duration is set to 60 seconds in linux, it is set to 120 seconds in Windows), I've come across <a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html">this article</a>, which suggests that the remedy for you could be much simpler: to <strong>never</strong> use tcp close() at server side. It means that after sending the answer to the http request, your servers should not actively close the tcp session (as they do now) and instead let the client send the FIN packet first (and if the client fails to do so in reasonable time, terminate the tcp session by sending a RST packet rather than by sending a FIN packet). The idea looks simple and logical. It seems that web browsers prefer to keep already established tcp connections open and reuse them for sending eventual further requests, so it is well possible that if your application stops actively terminating the connections after answering the request, the number of newly established connections might decrease a lot.</p></div><div id="comment-48034-info" class="comment-info"><span class="comment-age">(27 Nov '15, 13:46)</span> sindy</div></div></div><div id="comment-tools-47790" class="comment-tools"><span class="comments-showing"> showing 5 of 19 </span> <a href="#" class="show-all-comments-link">show 14 more comments</a></div><div class="clear"></div><div id="comment-47790-form-container" class="comment-form-container"></div><div class="clear"></div></div></td></tr></tbody></table>

</div>

<div class="paginator-container-left">

</div>

</div>

</div>

